{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$pdf417$detector$Detector.js",
"lineCount":13,
"mappings":"AAAAA,cAAA,CAAA,oEAAA,CAAyF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAiBjI,IAAIC,SAAY,IAAZA,EAAoB,IAAKA,CAAAA,QAAzBA,EAAsC,QAAQ,CAACC,CAAD,CAAI,CAAA,IAC9CC,EAAsB,UAAtBA,GAAI,MAAOC,OAAXD,EAAoCC,MAAOC,CAAAA,QADG,CACOC,EAAIH,CAAJG,EAASJ,CAAA,CAAEC,CAAF,CADhB,CACsBI,EAAI,CAC5E,IAAID,CAAJ,CAAO,MAAOA,EAAEE,CAAAA,IAAF,CAAON,CAAP,CACd,IAAIA,CAAJ,EAA6B,QAA7B,GAAS,MAAOA,EAAEO,CAAAA,MAAlB,CAAuC,MAAO,CAC1CC,KAAMA,QAAS,EAAG,CACVR,CAAJ,EAASK,CAAT,EAAcL,CAAEO,CAAAA,MAAhB,GAAwBP,CAAxB,CAA4B,IAAK,EAAjC,CACA,OAAO,CAAES,MAAOT,CAAPS,EAAYT,CAAA,CAAEK,CAAA,EAAF,CAAd,CAAsBK,KAAM,CAACV,CAA7B,CAFO,CADwB,CAM9C,MAAM,KAAIW,SAAJ,CAAcV,CAAA,CAAI,yBAAJ,CAAgC,iCAA9C,CAAN,CATkD,CAWtDW,OAAOC,CAAAA,cAAP,CAAsBf,OAAtB,CAA+B,YAA/B;AAA6C,CAAEW,MAAO,CAAA,CAAT,CAA7C,CAGA,KAAIK,cAAgBlB,OAAA,CAAQ,yDAAR,CAApB,CACImB,SAAWnB,OAAA,CAAQ,yDAAR,CADf,CAEIoB,SAAWpB,OAAA,CAAQ,yDAAR,CAFf,CAGIqB,uBAAyBrB,OAAA,CAAQ,kFAAR,CAazBsB,OAAAA,CAA0B,QAAS,EAAG,CACtCA,QAASA,SAAQ,EAAG,EAYpBA,QAASC,CAAAA,cAAT,CAA0BC,QAAS,CAACC,KAAD,CAAQC,KAAR,CAAeC,QAAf,CAAyB,CAIpDC,KAAAA,CAAYH,KAAMI,CAAAA,cAAN,EACZC,MAAAA,CAAqBR,QAASS,CAAAA,MAAT,CAAgBJ,QAAhB;AAA0BC,KAA1B,CACpBE,MAAmBnB,CAAAA,MAAxB,GACIiB,KAEA,CAFYA,KAAUI,CAAAA,KAAV,EAEZ,CADAJ,KAAUK,CAAAA,SAAV,EACA,CAAAH,KAAA,CAAqBR,QAASS,CAAAA,MAAT,CAAgBJ,QAAhB,CAA0BC,KAA1B,CAHzB,CAKA,OAAO,KAAIP,sBAAuBa,CAAAA,OAA3B,CAAmCN,KAAnC,CAA8CE,KAA9C,CAXiD,CAoB5DR,SAASS,CAAAA,MAAT,CAAkBI,QAAS,CAACR,QAAD,CAAWC,SAAX,CAAsB,CAM7C,IAN6C,IACzCQ,GADyC,CACpCC,EADoC,CAEzCP,mBAAqB,EAFoB,CAGzCQ,IAAM,CAHmC,CAIzCC,OAAS,CAJgC,CAKzCC,kBAAoB,CAAA,CACxB,CAAOF,GAAP,CAAaV,SAAUa,CAAAA,SAAV,EAAb,CAAA,CAAoC,CAChC,IAAIC,SAAWpB,QAASqB,CAAAA,YAAT,CAAsBf,SAAtB,CAAiCU,GAAjC,CAAsCC,MAAtC,CACf,IAAmB,IAAnB,EAAIG,QAAA,CAAS,CAAT,CAAJ,EAA0C,IAA1C,EAA2BA,QAAA,CAAS,CAAT,CAA3B,CAAgD,CAC5C,GAAI,CAACF,iBAAL,CAEI,KAIJA,kBAAA,CAAoB,CAAA,CACpBD,OAAA,CAAS,CACT,IAAI,CACA,IADA,IACSK,sBAAwBR,GAAA,CAAM,IAAK,EAAX;AAAcjC,QAAA,CAAS2B,kBAAT,CAAtCc,CADT,CAC8EC,uBAAyBD,oBAAqBhC,CAAAA,IAArB,EAAvG,CAAoI,CAACiC,sBAAuB/B,CAAAA,IAA5J,CAAkK+B,sBAAlK,CAA2LD,oBAAqBhC,CAAAA,IAArB,EAA3L,CAAwN,CACpN,IAAIkC,kBAAoBD,sBAAuBhC,CAAAA,KACnB,KAA5B,EAAIiC,iBAAA,CAAkB,CAAlB,CAAJ,GACIR,GADJ,CACUS,IAAKC,CAAAA,KAAL,CAAWD,IAAKE,CAAAA,GAAL,CAASX,GAAT,CAAcQ,iBAAA,CAAkB,CAAlB,CAAqBI,CAAAA,IAArB,EAAd,CAAX,CADV,CAG4B,KAA5B,EAAIJ,iBAAA,CAAkB,CAAlB,CAAJ,GACIR,GADJ,CACUS,IAAKE,CAAAA,GAAL,CAASX,GAAT,CAAcS,IAAKC,CAAAA,KAAL,CAAWF,iBAAA,CAAkB,CAAlB,CAAqBI,CAAAA,IAArB,EAAX,CAAd,CADV,CALoN,CADxN,CAWJ,MAAOC,KAAP,CAAc,CAAEf,GAAA,CAAM,CAAEgB,MAAOD,KAAT,CAAR,CAXd,OAYQ,CACJ,GAAI,CACIN,sBAAJ,EAA8B,CAACA,sBAAuB/B,CAAAA,IAAtD,GAA+DuB,EAA/D,CAAoEO,oBAAqBS,CAAAA,MAAzF;AAAkGhB,EAAG3B,CAAAA,IAAH,CAAQkC,oBAAR,CADlG,CAAJ,OAGQ,CAAE,GAAIR,GAAJ,CAAS,KAAMA,IAAIgB,CAAAA,KAAV,CAAX,CAJJ,CAMRd,GAAA,EAAOhB,QAASgC,CAAAA,QA3B4B,CAAhD,IAAA,CA8BAd,iBAAA,CAAoB,CAAA,CACpBV,mBAAmByB,CAAAA,IAAnB,CAAwBb,QAAxB,CACA,IAAI,CAACf,QAAL,CACI,KAIe,KAAnB,EAAIe,QAAA,CAAS,CAAT,CAAJ,EACIH,MACA,CADSQ,IAAKC,CAAAA,KAAL,CAAWN,QAAA,CAAS,CAAT,CAAYc,CAAAA,IAAZ,EAAX,CACT,CAAAlB,GAAA,CAAMS,IAAKC,CAAAA,KAAL,CAAWN,QAAA,CAAS,CAAT,CAAYQ,CAAAA,IAAZ,EAAX,CAFV,GAKIX,MACA,CADSQ,IAAKC,CAAAA,KAAL,CAAWN,QAAA,CAAS,CAAT,CAAYc,CAAAA,IAAZ,EAAX,CACT,CAAAlB,GAAA,CAAMS,IAAKC,CAAAA,KAAL,CAAWN,QAAA,CAAS,CAAT,CAAYQ,CAAAA,IAAZ,EAAX,CANV,CArCA,CAFgC,CAgDpC,MAAOpB,mBAtDsC,CAuEjDR,SAASqB,CAAAA,YAAT,CAAwBc,QAAS,CAACC,MAAD,CAASC,QAAT,CAAmBC,WAAnB,CAAgC,CAC7D,IAAIC,OAASH,MAAOjB,CAAAA,SAAP,EAAb,CACIqB,MAAQJ,MAAOK,CAAAA,QAAP,EADZ,CAGIC,OAAaC,KAAJ,CAAU,CAAV,CACb3C,SAAS4C,CAAAA,YAAT,CAAsBF,MAAtB;AAA8B1C,QAAS6C,CAAAA,mBAAT,CAA6BT,MAA7B,CAAqCG,MAArC,CAA6CC,KAA7C,CAAoDH,QAApD,CAA8DC,WAA9D,CAA2EtC,QAAS8C,CAAAA,aAApF,CAA9B,CAAkI9C,QAAS+C,CAAAA,qBAA3I,CACiB,KAAjB,EAAIL,MAAA,CAAO,CAAP,CAAJ,GACIJ,WACA,CADcb,IAAKC,CAAAA,KAAL,CAAWgB,MAAA,CAAO,CAAP,CAAUR,CAAAA,IAAV,EAAX,CACd,CAAAG,QAAA,CAAWZ,IAAKC,CAAAA,KAAL,CAAWgB,MAAA,CAAO,CAAP,CAAUd,CAAAA,IAAV,EAAX,CAFf,CAIA5B,SAAS4C,CAAAA,YAAT,CAAsBF,MAAtB,CAA8B1C,QAAS6C,CAAAA,mBAAT,CAA6BT,MAA7B,CAAqCG,MAArC,CAA6CC,KAA7C,CAAoDH,QAApD,CAA8DC,WAA9D,CAA2EtC,QAASgD,CAAAA,YAApF,CAA9B,CAAiIhD,QAASiD,CAAAA,oBAA1I,CACA,OAAOP,OAXsD,CAajE1C,SAAS4C,CAAAA,YAAT,CAAwBM,QAAS,CAACR,MAAD,CAASS,SAAT,CAAoBC,kBAApB,CAAwC,CACrE,IAAK,IAAIjE,EAAI,CAAb,CAAgBA,CAAhB,CAAoBiE,kBAAmB/D,CAAAA,MAAvC,CAA+CF,CAAA,EAA/C,CACIuD,MAAA,CAAOU,kBAAA,CAAmBjE,CAAnB,CAAP,CAAA;AAAgCgE,SAAA,CAAUhE,CAAV,CAFiC,CAKzEa,SAAS6C,CAAAA,mBAAT,CAA+BQ,QAAS,CAACjB,MAAD,CAASG,MAAT,CAAiBC,KAAjB,CAAwBH,QAAxB,CAAkCC,WAAlC,CAA+CgB,OAA/C,CAAwD,CAK5F,IAHA,IAAIZ,OAAaC,KAAJ,CAAU,CAAV,CAAb,CACIY,MAAQ,CAAA,CADZ,CAEIC,SAAW,IAAIC,UAAJ,CAAeH,OAAQjE,CAAAA,MAAvB,CACf,CAAOgD,QAAP,CAAkBE,MAAlB,CAA0BF,QAA1B,EAAsCrC,QAASgC,CAAAA,QAA/C,CAAyD,CACrD,IAAI0B,IAAM1D,QAAS2D,CAAAA,gBAAT,CAA0BvB,MAA1B,CAAkCE,WAAlC,CAA+CD,QAA/C,CAAyDG,KAAzD,CAAgE,CAAA,CAAhE,CAAuEc,OAAvE,CAAgFE,QAAhF,CACV,IAAW,IAAX,EAAIE,GAAJ,CAAiB,CACb,IAAA,CAAkB,CAAlB,CAAOrB,QAAP,CAAA,CAEI,GADIuB,KACA,CADiB5D,QAAS2D,CAAAA,gBAAT,CAA0BvB,MAA1B,CAAkCE,WAAlC,CAA+C,EAAED,QAAjD,CAA2DG,KAA3D,CAAkE,CAAA,CAAlE,CAAyEc,OAAzE,CAAkFE,QAAlF,CACjB,CAAkB,IAAlB,EAAAI,KAAJ,CACIF,GAAA,CAAME,KADV,KAGK,CACDvB,QAAA,EACA,MAFC,CAKTK,MAAA,CAAO,CAAP,CAAA,CAAY,IAAI9C,aAAcgB,CAAAA,OAAlB,CAA0B8C,GAAA,CAAI,CAAJ,CAA1B;AAAkCrB,QAAlC,CACZK,OAAA,CAAO,CAAP,CAAA,CAAY,IAAI9C,aAAcgB,CAAAA,OAAlB,CAA0B8C,GAAA,CAAI,CAAJ,CAA1B,CAAkCrB,QAAlC,CACZkB,MAAA,CAAQ,CAAA,CACR,MAda,CAFoC,CAmBrDM,WAAAA,CAAUxB,QAAVwB,CAAqB,CAEzB,IAAIN,KAAJ,CAAW,CACP,IAAIO,gBAAkB,CAEtB,KADIF,KACJ,CADqBH,UAAWM,CAAAA,IAAX,CAAgB,CAACtC,IAAKC,CAAAA,KAAL,CAAWgB,MAAA,CAAO,CAAP,CAAUR,CAAAA,IAAV,EAAX,CAAD,CAA+BT,IAAKC,CAAAA,KAAL,CAAWgB,MAAA,CAAO,CAAP,CAAUR,CAAAA,IAAV,EAAX,CAA/B,CAAhB,CACrB,CAAO2B,WAAP,CAAiBtB,MAAjB,CAAyBsB,WAAA,EAAzB,CAMI,GALIH,GAKA,CALM1D,QAAS2D,CAAAA,gBAAT,CAA0BvB,MAA1B,CAAkCwB,KAAA,CAAe,CAAf,CAAlC,CAAqDC,WAArD,CAA8DrB,KAA9D,CAAqE,CAAA,CAArE,CAA4Ec,OAA5E,CAAqFE,QAArF,CAKN,CAAO,IAAP,EAAAE,GAAA,EACAjC,IAAKuC,CAAAA,GAAL,CAASJ,KAAA,CAAe,CAAf,CAAT,CAA6BF,GAAA,CAAI,CAAJ,CAA7B,CADA,CACuC1D,QAASiE,CAAAA,iBADhD,EAEAxC,IAAKuC,CAAAA,GAAL,CAASJ,KAAA,CAAe,CAAf,CAAT,CAA6BF,GAAA,CAAI,CAAJ,CAA7B,CAFA,CAEuC1D,QAASiE,CAAAA,iBAFpD,CAGIL,KACA,CADiBF,GACjB,CAAAI,eAAA,CAAkB,CAJtB,KAOI,IAAIA,eAAJ;AAAsB9D,QAASkE,CAAAA,qBAA/B,CACI,KADJ,KAIIJ,gBAAA,EAIZD,YAAA,EAAWC,eAAX,CAA6B,CAC7BpB,OAAA,CAAO,CAAP,CAAA,CAAY,IAAI9C,aAAcgB,CAAAA,OAAlB,CAA0BgD,KAAA,CAAe,CAAf,CAA1B,CAA6CC,WAA7C,CACZnB,OAAA,CAAO,CAAP,CAAA,CAAY,IAAI9C,aAAcgB,CAAAA,OAAlB,CAA0BgD,KAAA,CAAe,CAAf,CAA1B,CAA6CC,WAA7C,CA1BL,CA4BPA,WAAJ,CAAcxB,QAAd,CAAyBrC,QAASmE,CAAAA,kBAAlC,EACIrE,QAASc,CAAAA,OAAQwD,CAAAA,IAAjB,CAAsB1B,MAAtB,CAA8B,IAA9B,CAEJ,OAAOA,OAzDqF,CAqEhG1C,SAAS2D,CAAAA,gBAAT,CAA4BU,QAAS,CAACjC,MAAD,CAASnB,MAAT,CAAiBD,GAAjB,CAAsBwB,KAAtB,CAA6B8B,UAA7B,CAAyChB,OAAzC,CAAkDE,QAAlD,CAA4D,CAC7F1D,QAASc,CAAAA,OAAQ2D,CAAAA,UAAjB,CAA4Bf,QAA5B,CAAsC,CAAtC,CAAyCA,QAASnE,CAAAA,MAAlD,CAA0D,CAA1D,CAIA,KAFA,IAAImF,WAAa,CAEjB,CAAOpC,MAAOqC,CAAAA,GAAP,CAAWC,MAAX,CAAyB1D,GAAzB,CAAP,EAAuD,CAAvD,CAAwC0D,MAAxC;AAA4DF,UAAA,EAA5D,CAA2ExE,QAAS2E,CAAAA,eAApF,CAAA,CACID,MAAA,EAEAE,WAAAA,CAAIF,MAGR,KAFA,IAAIG,gBAAkB,CAAtB,CACIC,cAAgBxB,OAAQjE,CAAAA,MAC5B,CAA+BuF,UAA/B,CAAmCpC,KAAnC,CAA0CoC,UAAA,EAA1C,CAEI,GADYxC,MAAOqC,CAAAA,GAAPM,CAAWH,UAAXG,CAAc/D,GAAd+D,CACZ,GAAcC,UAAd,CACIxB,QAAA,CAASqB,eAAT,CAAA,EADJ,KAGK,CACD,GAAIA,eAAJ,GAAwBC,aAAxB,CAAwC,CAAxC,CAA2C,CACvC,GAAI9E,QAASiF,CAAAA,oBAAT,CAA8BzB,QAA9B,CAAwCF,OAAxC,CAAiDtD,QAASkF,CAAAA,uBAA1D,CAAJ,CAAyFlF,QAASmF,CAAAA,gBAAlG,CACI,MAAO,KAAI1B,UAAJ,CAAe,CAACiB,MAAD,CAAeE,UAAf,CAAf,CAEXF,OAAA,EAAgBlB,QAAA,CAAS,CAAT,CAAhB,CAA8BA,QAAA,CAAS,CAAT,CAC9B3D,SAASe,CAAAA,OAAQwE,CAAAA,SAAjB,CAA2B5B,QAA3B,CAAqC,CAArC,CAAwCA,QAAxC,CAAkD,CAAlD,CAAqDqB,eAArD;AAAuE,CAAvE,CACArB,SAAA,CAASqB,eAAT,CAA2B,CAA3B,CAAA,CAAgC,CAChCrB,SAAA,CAASqB,eAAT,CAAA,CAA4B,CAC5BA,gBAAA,EARuC,CAA3C,IAWIA,gBAAA,EAEJrB,SAAA,CAASqB,eAAT,CAAA,CAA4B,CAC5BG,WAAA,CAAU,CAACA,UAfV,CAkBT,MAAIH,gBAAJ,GAAwBC,aAAxB,CAAwC,CAAxC,EACI9E,QAASiF,CAAAA,oBAAT,CAA8BzB,QAA9B,CAAwCF,OAAxC,CAAiDtD,QAASkF,CAAAA,uBAA1D,CADJ,CACyFlF,QAASmF,CAAAA,gBADlG,CAEW,IAAI1B,UAAJ,CAAe,CAACiB,MAAD,CAAeE,UAAf,CAAmB,CAAnB,CAAf,CAFX,CAIO,IAtCsF,CAmDjG5E,SAASiF,CAAAA,oBAAT,CAAgCI,QAAS,CAAC7B,QAAD,CAAWF,OAAX,CAAoBgC,qBAApB,CAA2C,CAIhF,IAHA,IAAIC,YAAc/B,QAASnE,CAAAA,MAA3B,CACImG,MAAQ,CADZ,CAEIV,cAAgB,CAFpB,CAGS3F,EAAI,CAAb,CAAgBA,CAAhB,CAAoBoG,WAApB,CAAiCpG,CAAA,EAAjC,CACIqG,KACA;AADShC,QAAA,CAASrE,CAAT,CACT,CAAA2F,aAAA,EAAiBxB,OAAA,CAAQnE,CAAR,CAErB,IAAIqG,KAAJ,CAAYV,aAAZ,CAGI,MAAmCW,SAKnCC,cAAAA,CAAeF,KAAfE,CAAuBZ,aAC3BQ,sBAAA,EAAyBI,aAEzB,KAAK,IAAId,EADLe,CACKf,CADW,CACpB,CAAgBA,CAAhB,CAAoBW,WAApB,CAAiCX,CAAA,EAAjC,CAAsC,CAClC,IAAIgB,QAAUpC,QAAA,CAASoB,CAAT,CAAd,CACIiB,cAAgBvC,OAAA,CAAQsB,CAAR,CAAhBiB,CAA6BH,aAC7BI,QAAAA,CAAWF,OAAA,CAAUC,aAAV,CAA0BD,OAA1B,CAAoCC,aAApC,CAAoDA,aAApD,CAAoED,OACnF,IAAIE,OAAJ,CAAeR,qBAAf,CACI,MAAmCG,SAEvCE,EAAA,EAAiBG,OAPiB,CAStC,MAAOH,EAAP,CAAuBH,KA5ByD,CA8BpFxF,SAAS+C,CAAAA,qBAAT,CAAiCU,UAAWM,CAAAA,IAAX,CAAgB,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAAU,CAAV,CAAhB,CACjC/D,SAASiD,CAAAA,oBAAT,CAAgCQ,UAAWM,CAAAA,IAAX,CAAgB,CAAC,CAAD;AAAI,CAAJ,CAAO,CAAP,CAAU,CAAV,CAAhB,CAChC/D,SAASmF,CAAAA,gBAAT,CAA4B,GAC5BnF,SAASkF,CAAAA,uBAAT,CAAmC,EAGnClF,SAAS8C,CAAAA,aAAT,CAAyBW,UAAWM,CAAAA,IAAX,CAAgB,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAAU,CAAV,CAAa,CAAb,CAAgB,CAAhB,CAAmB,CAAnB,CAAsB,CAAtB,CAAhB,CAEzB/D,SAASgD,CAAAA,YAAT,CAAwBS,UAAWM,CAAAA,IAAX,CAAgB,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAAU,CAAV,CAAa,CAAb,CAAgB,CAAhB,CAAmB,CAAnB,CAAsB,CAAtB,CAAyB,CAAzB,CAAhB,CACxB/D,SAAS2E,CAAAA,eAAT,CAA2B,CAC3B3E,SAASiE,CAAAA,iBAAT,CAA6B,CAG7BjE,SAASkE,CAAAA,qBAAT,CAAiC,EAGjClE,SAASgC,CAAAA,QAAT,CAAoB,CACpBhC,SAASmE,CAAAA,kBAAT,CAA8B,EAC9B,OAAOnE,SAlS+B,CAAZ,EAoS9BpB,QAAQgC,CAAAA,OAAR,CAAkBZ,MAnV+G;",
"sources":["node_modules/@zxing/library/cjs/core/pdf417/detector/Detector.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$pdf417$detector$Detector\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n* Copyright 2009 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// import com.google.zxing.NotFoundException;\n// import com.google.zxing.ResultPoint;\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar System_1 = require(\"../../util/System\");\nvar Arrays_1 = require(\"../../util/Arrays\");\nvar PDF417DetectorResult_1 = require(\"./PDF417DetectorResult\");\n// import java.util.ArrayList;\n// import java.util.Arrays;\n// import java.util.List;\n// import java.util.Map;\n/**\n * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the\n * PDF417 Code is rotated or skewed, or partially obscured.</p>\n *\n * @author SITA Lab (kevin.osullivan@sita.aero)\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Guenther Grau\n */\nvar Detector = /** @class */ (function () {\n    function Detector() {\n    }\n    /**\n     * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>\n     *\n     * @param image barcode image to decode\n     * @param hints optional hints to detector\n     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n     * be found and returned\n     * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code\n     * @throws NotFoundException if no PDF417 Code can be found\n     */\n    Detector.detectMultiple = function (image, hints, multiple) {\n        // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even\n        // different binarizers\n        // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);\n        var bitMatrix = image.getBlackMatrix();\n        var barcodeCoordinates = Detector.detect(multiple, bitMatrix);\n        if (!barcodeCoordinates.length) {\n            bitMatrix = bitMatrix.clone();\n            bitMatrix.rotate180();\n            barcodeCoordinates = Detector.detect(multiple, bitMatrix);\n        }\n        return new PDF417DetectorResult_1.default(bitMatrix, barcodeCoordinates);\n    };\n    /**\n     * Detects PDF417 codes in an image. Only checks 0 degree rotation\n     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n     * be found and returned\n     * @param bitMatrix bit matrix to detect barcodes in\n     * @return List of ResultPoint arrays containing the coordinates of found barcodes\n     */\n    Detector.detect = function (multiple, bitMatrix) {\n        var e_1, _a;\n        var barcodeCoordinates = new Array();\n        var row = 0;\n        var column = 0;\n        var foundBarcodeInRow = false;\n        while (row < bitMatrix.getHeight()) {\n            var vertices = Detector.findVertices(bitMatrix, row, column);\n            if (vertices[0] == null && vertices[3] == null) {\n                if (!foundBarcodeInRow) {\n                    // we didn't find any barcode so that's the end of searching\n                    break;\n                }\n                // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly\n                // below the lowest barcode we found so far.\n                foundBarcodeInRow = false;\n                column = 0;\n                try {\n                    for (var barcodeCoordinates_1 = (e_1 = void 0, __values(barcodeCoordinates)), barcodeCoordinates_1_1 = barcodeCoordinates_1.next(); !barcodeCoordinates_1_1.done; barcodeCoordinates_1_1 = barcodeCoordinates_1.next()) {\n                        var barcodeCoordinate = barcodeCoordinates_1_1.value;\n                        if (barcodeCoordinate[1] != null) {\n                            row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));\n                        }\n                        if (barcodeCoordinate[3] != null) {\n                            row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (barcodeCoordinates_1_1 && !barcodeCoordinates_1_1.done && (_a = barcodeCoordinates_1.return)) _a.call(barcodeCoordinates_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n                row += Detector.ROW_STEP;\n                continue;\n            }\n            foundBarcodeInRow = true;\n            barcodeCoordinates.push(vertices);\n            if (!multiple) {\n                break;\n            }\n            // if we didn't find a right row indicator column, then continue the search for the next barcode after the\n            // start pattern of the barcode just found.\n            if (vertices[2] != null) {\n                column = Math.trunc(vertices[2].getX());\n                row = Math.trunc(vertices[2].getY());\n            }\n            else {\n                column = Math.trunc(vertices[4].getX());\n                row = Math.trunc(vertices[4].getY());\n            }\n        }\n        return barcodeCoordinates;\n    };\n    /**\n     * Locate the vertices and the codewords area of a black blob using the Start\n     * and Stop patterns as locators.\n     *\n     * @param matrix the scanned barcode image.\n     * @return an array containing the vertices:\n     *           vertices[0] x, y top left barcode\n     *           vertices[1] x, y bottom left barcode\n     *           vertices[2] x, y top right barcode\n     *           vertices[3] x, y bottom right barcode\n     *           vertices[4] x, y top left codeword area\n     *           vertices[5] x, y bottom left codeword area\n     *           vertices[6] x, y top right codeword area\n     *           vertices[7] x, y bottom right codeword area\n     */\n    Detector.findVertices = function (matrix, startRow, startColumn) {\n        var height = matrix.getHeight();\n        var width = matrix.getWidth();\n        // const result = new ResultPoint[8];\n        var result = new Array(8);\n        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.START_PATTERN), Detector.INDEXES_START_PATTERN);\n        if (result[4] != null) {\n            startColumn = Math.trunc(result[4].getX());\n            startRow = Math.trunc(result[4].getY());\n        }\n        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.STOP_PATTERN), Detector.INDEXES_STOP_PATTERN);\n        return result;\n    };\n    Detector.copyToResult = function (result, tmpResult, destinationIndexes) {\n        for (var i = 0; i < destinationIndexes.length; i++) {\n            result[destinationIndexes[i]] = tmpResult[i];\n        }\n    };\n    Detector.findRowsWithPattern = function (matrix, height, width, startRow, startColumn, pattern) {\n        // const result = new ResultPoint[4];\n        var result = new Array(4);\n        var found = false;\n        var counters = new Int32Array(pattern.length);\n        for (; startRow < height; startRow += Detector.ROW_STEP) {\n            var loc = Detector.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);\n            if (loc != null) {\n                while (startRow > 0) {\n                    var previousRowLoc = Detector.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);\n                    if (previousRowLoc != null) {\n                        loc = previousRowLoc;\n                    }\n                    else {\n                        startRow++;\n                        break;\n                    }\n                }\n                result[0] = new ResultPoint_1.default(loc[0], startRow);\n                result[1] = new ResultPoint_1.default(loc[1], startRow);\n                found = true;\n                break;\n            }\n        }\n        var stopRow = startRow + 1;\n        // Last row of the current symbol that contains pattern\n        if (found) {\n            var skippedRowCount = 0;\n            var previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);\n            for (; stopRow < height; stopRow++) {\n                var loc = Detector.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);\n                // a found pattern is only considered to belong to the same barcode if the start and end positions\n                // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With\n                // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly\n                // larger drift and don't check for skipped rows.\n                if (loc != null &&\n                    Math.abs(previousRowLoc[0] - loc[0]) < Detector.MAX_PATTERN_DRIFT &&\n                    Math.abs(previousRowLoc[1] - loc[1]) < Detector.MAX_PATTERN_DRIFT) {\n                    previousRowLoc = loc;\n                    skippedRowCount = 0;\n                }\n                else {\n                    if (skippedRowCount > Detector.SKIPPED_ROW_COUNT_MAX) {\n                        break;\n                    }\n                    else {\n                        skippedRowCount++;\n                    }\n                }\n            }\n            stopRow -= skippedRowCount + 1;\n            result[2] = new ResultPoint_1.default(previousRowLoc[0], stopRow);\n            result[3] = new ResultPoint_1.default(previousRowLoc[1], stopRow);\n        }\n        if (stopRow - startRow < Detector.BARCODE_MIN_HEIGHT) {\n            Arrays_1.default.fill(result, null);\n        }\n        return result;\n    };\n    /**\n     * @param matrix row of black/white values to search\n     * @param column x position to start search\n     * @param row y position to start search\n     * @param width the number of pixels to search on this row\n     * @param pattern pattern of counts of number of black and white pixels that are\n     *                 being searched for as a pattern\n     * @param counters array of counters, as long as pattern, to re-use\n     * @return start/end horizontal offset of guard pattern, as an array of two ints.\n     */\n    Detector.findGuardPattern = function (matrix, column, row, width, whiteFirst, pattern, counters) {\n        Arrays_1.default.fillWithin(counters, 0, counters.length, 0);\n        var patternStart = column;\n        var pixelDrift = 0;\n        // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels\n        while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector.MAX_PIXEL_DRIFT) {\n            patternStart--;\n        }\n        var x = patternStart;\n        var counterPosition = 0;\n        var patternLength = pattern.length;\n        for (var isWhite = whiteFirst; x < width; x++) {\n            var pixel = matrix.get(x, row);\n            if (pixel !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {\n                        return new Int32Array([patternStart, x]);\n                    }\n                    patternStart += counters[0] + counters[1];\n                    System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        if (counterPosition === patternLength - 1 &&\n            Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {\n            return new Int32Array([patternStart, x - 1]);\n        }\n        return null;\n    };\n    /**\n     * Determines how closely a set of observed counts of runs of black/white\n     * values matches a given target pattern. This is reported as the ratio of\n     * the total variance from the expected pattern proportions across all\n     * pattern elements, to the length of the pattern.\n     *\n     * @param counters observed counters\n     * @param pattern expected pattern\n     * @param maxIndividualVariance The most any counter can differ before we give up\n     * @return ratio of total variance between counters and pattern compared to total pattern size\n     */\n    Detector.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n        var numCounters = counters.length;\n        var total = 0;\n        var patternLength = 0;\n        for (var i = 0; i < numCounters; i++) {\n            total += counters[i];\n            patternLength += pattern[i];\n        }\n        if (total < patternLength) {\n            // If we don't even have one pixel per unit of bar width, assume this\n            // is too small to reliably match, so fail:\n            return /*Float.POSITIVE_INFINITY*/ Infinity;\n        }\n        // We're going to fake floating-point math in integers. We just need to use more bits.\n        // Scale up patternLength so that intermediate values below like scaledCounter will have\n        // more \"significant digits\".\n        var unitBarWidth = total / patternLength;\n        maxIndividualVariance *= unitBarWidth;\n        var totalVariance = 0.0;\n        for (var x = 0; x < numCounters; x++) {\n            var counter = counters[x];\n            var scaledPattern = pattern[x] * unitBarWidth;\n            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n            if (variance > maxIndividualVariance) {\n                return /*Float.POSITIVE_INFINITY*/ Infinity;\n            }\n            totalVariance += variance;\n        }\n        return totalVariance / total;\n    };\n    Detector.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);\n    Detector.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);\n    Detector.MAX_AVG_VARIANCE = 0.42;\n    Detector.MAX_INDIVIDUAL_VARIANCE = 0.8;\n    // B S B S B S B S Bar/Space pattern\n    // 11111111 0 1 0 1 0 1 000\n    Detector.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);\n    // 1111111 0 1 000 1 0 1 00 1\n    Detector.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);\n    Detector.MAX_PIXEL_DRIFT = 3;\n    Detector.MAX_PATTERN_DRIFT = 5;\n    // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.\n    // if we set the value too high, then we might detect the start pattern from a neighbor barcode.\n    Detector.SKIPPED_ROW_COUNT_MAX = 25;\n    // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least\n    // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.\n    Detector.ROW_STEP = 5;\n    Detector.BARCODE_MIN_HEIGHT = 10;\n    return Detector;\n}());\nexports.default = Detector;\n//# sourceMappingURL=Detector.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","Object","defineProperty","ResultPoint_1","System_1","Arrays_1","PDF417DetectorResult_1","Detector","detectMultiple","Detector.detectMultiple","image","hints","multiple","bitMatrix","getBlackMatrix","barcodeCoordinates","detect","clone","rotate180","default","Detector.detect","e_1","_a","row","column","foundBarcodeInRow","getHeight","vertices","findVertices","barcodeCoordinates_1","barcodeCoordinates_1_1","barcodeCoordinate","Math","trunc","max","getY","e_1_1","error","return","ROW_STEP","push","getX","Detector.findVertices","matrix","startRow","startColumn","height","width","getWidth","result","Array","copyToResult","findRowsWithPattern","START_PATTERN","INDEXES_START_PATTERN","STOP_PATTERN","INDEXES_STOP_PATTERN","Detector.copyToResult","tmpResult","destinationIndexes","Detector.findRowsWithPattern","pattern","found","counters","Int32Array","loc","findGuardPattern","previousRowLoc","stopRow","skippedRowCount","from","abs","MAX_PATTERN_DRIFT","SKIPPED_ROW_COUNT_MAX","BARCODE_MIN_HEIGHT","fill","Detector.findGuardPattern","whiteFirst","fillWithin","pixelDrift","get","patternStart","MAX_PIXEL_DRIFT","x","counterPosition","patternLength","pixel","isWhite","patternMatchVariance","MAX_INDIVIDUAL_VARIANCE","MAX_AVG_VARIANCE","arraycopy","Detector.patternMatchVariance","maxIndividualVariance","numCounters","total","Infinity","unitBarWidth","totalVariance","counter","scaledPattern","variance"]
}
