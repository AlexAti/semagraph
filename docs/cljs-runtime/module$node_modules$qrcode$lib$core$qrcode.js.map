{
"version":3,
"file":"module$node_modules$qrcode$lib$core$qrcode.js",
"lineCount":14,
"mappings":"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",
"sources":["node_modules/qrcode/lib/core/qrcode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$qrcode$lib$core$qrcode\"] = function(global,require,module,exports) {\nconst Utils = require('./utils')\nconst ECLevel = require('./error-correction-level')\nconst BitBuffer = require('./bit-buffer')\nconst BitMatrix = require('./bit-matrix')\nconst AlignmentPattern = require('./alignment-pattern')\nconst FinderPattern = require('./finder-pattern')\nconst MaskPattern = require('./mask-pattern')\nconst ECCode = require('./error-correction-code')\nconst ReedSolomonEncoder = require('./reed-solomon-encoder')\nconst Version = require('./version')\nconst FormatInfo = require('./format-info')\nconst Mode = require('./mode')\nconst Segments = require('./segments')\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  const size = matrix.size\n  const pos = FinderPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (let c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  const size = matrix.size\n\n  for (let r = 8; r < size - 8; r++) {\n    const value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  const pos = AlignmentPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -2; r <= 2; r++) {\n      for (let c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  const size = matrix.size\n  const bits = Version.getEncodedBits(version)\n  let row, col, mod\n\n  for (let i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  const size = matrix.size\n  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  let i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix}  matrix Modules matrix\n * @param  {Uint8Array} data   Data codewords\n */\nfunction setupData (matrix, data) {\n  const size = matrix.size\n  let inc = -1\n  let row = size - 1\n  let bitIndex = 7\n  let byteIndex = 0\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (let c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          let dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Uint8Array}                    Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  const buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (let i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Uint8Array}                     Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  const blocksInGroup2 = totalCodewords % ecTotalBlocks\n  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  const rs = new ReedSolomonEncoder(ecCount)\n\n  let offset = 0\n  const dcData = new Array(ecTotalBlocks)\n  const ecData = new Array(ecTotalBlocks)\n  let maxDataSize = 0\n  const buffer = new Uint8Array(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (let b = 0; b < ecTotalBlocks; b++) {\n    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  const data = new Uint8Array(totalCodewords)\n  let index = 0\n  let i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  let segments\n\n  if (Array.isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    let estimatedVersion = version\n\n    if (!estimatedVersion) {\n      const rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  const dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  const moduleCount = Utils.getSymbolSize(version)\n  const modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  let errorCorrectionLevel = ECLevel.M\n  let version\n  let mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","setupFormatInfo","matrix","errorCorrectionLevel","maskPattern","size","bits","FormatInfo","getEncodedBits","mod","i","set","createData","version","segments","buffer","BitBuffer","forEach","data","put","mode","bit","getLength","Mode","getCharCountIndicator","write","totalCodewords","Utils","getSymbolTotalCodewords","ecTotalCodewords","ECCode","getTotalCodewordsCount","dataTotalCodewordsBits","getLengthInBits","putBit","remainingByte","createCodewords","bitBuffer","dataTotalCodewords","ecTotalBlocks","getBlocksCount","blocksInGroup1","dataCodewordsInGroup1","Math","floor","dataCodewordsInGroup2","ecCount","totalCodewordsInGroup1","rs","ReedSolomonEncoder","offset","dcData","Array","ecData","maxDataSize","Uint8Array","b","dataSize","slice","encode","max","index","r","length","ECLevel","BitMatrix","AlignmentPattern","FinderPattern","MaskPattern","Version","Segments","create","exports.create","options","Error","M","from","mask","toSJISFunc","setToSJISFunction","isArray","fromArray","estimatedVersion","rawSegments","rawSplit","getBestVersionForData","fromString","bestVersion","dataBits","moduleCount","getSymbolSize","modules","pos","getPositions","row","col","c","value","inc","bitIndex","byteIndex","isReserved","dark","isNaN","getBestMask","bind","applyMask"]
}
