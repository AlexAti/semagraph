shadow$provide.module$node_modules$$zxing$library$cjs$core$pdf417$decoder$ec$ErrorCorrection=function(global,require,module,exports){var __values=this&&this.__values||function(o){var s="function"===typeof Symbol&&Symbol.iterator,m=s&&o[s],i=0;if(m)return m.call(o);if(o&&"number"===typeof o.length)return{next:function(){o&&i>=o.length&&(o=void 0);return{value:o&&o[i++],done:!o}}};throw new TypeError(s?"Object is not iterable.":"Symbol.iterator is not defined.");};Object.defineProperty(exports,"__esModule",
{value:!0});var ChecksumException_1=require("module$node_modules$$zxing$library$cjs$core$ChecksumException"),ModulusPoly_1=require("module$node_modules$$zxing$library$cjs$core$pdf417$decoder$ec$ModulusPoly"),ModulusGF_1=require("module$node_modules$$zxing$library$cjs$core$pdf417$decoder$ec$ModulusGF");global=function(){function ErrorCorrection(){this.field=ModulusGF_1.default.PDF417_GF}ErrorCorrection.prototype.decode=function(received,numECCodewords,erasures){for(var e_1,_a,poly=new ModulusPoly_1.default(this.field,
received),S=new Int32Array(numECCodewords),error=!1,i=numECCodewords;0<i;i--){var evaluation=poly.evaluateAt(this.field.exp(i));S[numECCodewords-i]=evaluation;0!==evaluation&&(error=!0)}if(!error)return 0;i=this.field.getOne();if(null!=erasures)try{for(var erasures_1=__values(erasures),erasures_1_1=erasures_1.next();!erasures_1_1.done;erasures_1_1=erasures_1.next()){var b=this.field.exp(received.length-1-erasures_1_1.value),term=new ModulusPoly_1.default(this.field,new Int32Array([this.field.subtract(0,
b),1]));i=i.multiply(term)}}catch(e_1_1){e_1={error:e_1_1}}finally{try{erasures_1_1&&!erasures_1_1.done&&(_a=erasures_1.return)&&_a.call(erasures_1)}finally{if(e_1)throw e_1.error;}}i=new ModulusPoly_1.default(this.field,S);numECCodewords=this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords,1),i,numECCodewords);i=numECCodewords[0];erasures=numECCodewords[1];numECCodewords=this.findErrorLocations(i);erasures=this.findErrorMagnitudes(erasures,i,numECCodewords);for(i=0;i<numECCodewords.length;i++){e_1=
received.length-1-this.field.log(numECCodewords[i]);if(0>e_1)throw ChecksumException_1.default.getChecksumInstance();received[e_1]=this.field.subtract(received[e_1],erasures[i])}return numECCodewords.length};ErrorCorrection.prototype.runEuclideanAlgorithm=function(a,b,R){if(a.getDegree()<b.getDegree()){var temp=a;a=b;b=temp}temp=this.field.getZero();for(var t=this.field.getOne();b.getDegree()>=Math.round(R/2);){var rLastLast=a,tLastLast=temp;a=b;temp=t;if(a.isZero())throw ChecksumException_1.default.getChecksumInstance();
b=rLastLast;t=this.field.getZero();rLastLast=a.getCoefficient(a.getDegree());for(rLastLast=this.field.inverse(rLastLast);b.getDegree()>=a.getDegree()&&!b.isZero();){var degreeDiff=b.getDegree()-a.getDegree(),scale=this.field.multiply(b.getCoefficient(b.getDegree()),rLastLast);t=t.add(this.field.buildMonomial(degreeDiff,scale));b=b.subtract(a.multiplyByMonomial(degreeDiff,scale))}t=t.multiply(temp).subtract(tLastLast).negative()}R=t.getCoefficient(0);if(0===R)throw ChecksumException_1.default.getChecksumInstance();
R=this.field.inverse(R);a=t.multiply(R);R=b.multiply(R);return[a,R]};ErrorCorrection.prototype.findErrorLocations=function(errorLocator){for(var numErrors=errorLocator.getDegree(),result=new Int32Array(numErrors),e=0,i=1;i<this.field.getSize()&&e<numErrors;i++)0===errorLocator.evaluateAt(i)&&(result[e]=this.field.inverse(i),e++);if(e!==numErrors)throw ChecksumException_1.default.getChecksumInstance();return result};ErrorCorrection.prototype.findErrorMagnitudes=function(errorEvaluator,errorLocator,
errorLocations){for(var errorLocatorDegree=errorLocator.getDegree(),formalDerivativeCoefficients=new Int32Array(errorLocatorDegree),i=1;i<=errorLocatorDegree;i++)formalDerivativeCoefficients[errorLocatorDegree-i]=this.field.multiply(i,errorLocator.getCoefficient(i));errorLocator=new ModulusPoly_1.default(this.field,formalDerivativeCoefficients);errorLocatorDegree=errorLocations.length;formalDerivativeCoefficients=new Int32Array(errorLocatorDegree);for(i=0;i<errorLocatorDegree;i++){var xiInverse=this.field.inverse(errorLocations[i]),
numerator=this.field.subtract(0,errorEvaluator.evaluateAt(xiInverse));xiInverse=this.field.inverse(errorLocator.evaluateAt(xiInverse));formalDerivativeCoefficients[i]=this.field.multiply(numerator,xiInverse)}return formalDerivativeCoefficients};return ErrorCorrection}();exports.default=global}
//# sourceMappingURL=module$node_modules$$zxing$library$cjs$core$pdf417$decoder$ec$ErrorCorrection.js.map
