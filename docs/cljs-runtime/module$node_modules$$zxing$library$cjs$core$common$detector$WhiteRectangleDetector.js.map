{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$common$detector$WhiteRectangleDetector.js",
"lineCount":12,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/common/detector/WhiteRectangleDetector.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$common$detector$WhiteRectangleDetector\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common.detector {*/\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar MathUtils_1 = require(\"./MathUtils\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/**\n * <p>\n * Detects a candidate barcode-like rectangular region within an image. It\n * starts around the center of the image, increases the size of the candidate\n * region until it finds a white rectangular region. By keeping track of the\n * last black points it encountered, it determines the corners of the barcode.\n * </p>\n *\n * @author David Olivier\n */\nvar WhiteRectangleDetector = /** @class */ (function () {\n    // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n    //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n    // }\n    /**\n     * @param image barcode image to find a rectangle in\n     * @param initSize initial size of search area around center\n     * @param x x position of search center\n     * @param y y position of search center\n     * @throws NotFoundException if image is too small to accommodate {@code initSize}\n     */\n    function WhiteRectangleDetector(image, initSize /*int*/, x /*int*/, y /*int*/) {\n        this.image = image;\n        this.height = image.getHeight();\n        this.width = image.getWidth();\n        if (undefined === initSize || null === initSize) {\n            initSize = WhiteRectangleDetector.INIT_SIZE;\n        }\n        if (undefined === x || null === x) {\n            x = image.getWidth() / 2 | 0;\n        }\n        if (undefined === y || null === y) {\n            y = image.getHeight() / 2 | 0;\n        }\n        var halfsize = initSize / 2 | 0;\n        this.leftInit = x - halfsize;\n        this.rightInit = x + halfsize;\n        this.upInit = y - halfsize;\n        this.downInit = y + halfsize;\n        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n            throw new NotFoundException_1.default();\n        }\n    }\n    /**\n     * <p>\n     * Detects a candidate barcode-like rectangular region within an image. It\n     * starts around the center of the image, increases the size of the candidate\n     * region until it finds a white rectangular region.\n     * </p>\n     *\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\n     *         region. The first and last points are opposed on the diagonal, as\n     *         are the second and third. The first point will be the topmost\n     *         point and the last, the bottommost. The second point will be\n     *         leftmost and the third, the rightmost\n     * @throws NotFoundException if no Data Matrix Code can be found\n     */\n    WhiteRectangleDetector.prototype.detect = function () {\n        var left = this.leftInit;\n        var right = this.rightInit;\n        var up = this.upInit;\n        var down = this.downInit;\n        var sizeExceeded = false;\n        var aBlackPointFoundOnBorder = true;\n        var atLeastOneBlackPointFoundOnBorder = false;\n        var atLeastOneBlackPointFoundOnRight = false;\n        var atLeastOneBlackPointFoundOnBottom = false;\n        var atLeastOneBlackPointFoundOnLeft = false;\n        var atLeastOneBlackPointFoundOnTop = false;\n        var width = this.width;\n        var height = this.height;\n        while (aBlackPointFoundOnBorder) {\n            aBlackPointFoundOnBorder = false;\n            // .....\n            // .   |\n            // .....\n            var rightBorderNotWhite = true;\n            while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n                rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n                if (rightBorderNotWhite) {\n                    right++;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnRight = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnRight) {\n                    right++;\n                }\n            }\n            if (right >= width) {\n                sizeExceeded = true;\n                break;\n            }\n            // .....\n            // .   .\n            // .___.\n            var bottomBorderNotWhite = true;\n            while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n                bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n                if (bottomBorderNotWhite) {\n                    down++;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnBottom = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnBottom) {\n                    down++;\n                }\n            }\n            if (down >= height) {\n                sizeExceeded = true;\n                break;\n            }\n            // .....\n            // |   .\n            // .....\n            var leftBorderNotWhite = true;\n            while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n                leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n                if (leftBorderNotWhite) {\n                    left--;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnLeft = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnLeft) {\n                    left--;\n                }\n            }\n            if (left < 0) {\n                sizeExceeded = true;\n                break;\n            }\n            // .___.\n            // .   .\n            // .....\n            var topBorderNotWhite = true;\n            while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n                topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n                if (topBorderNotWhite) {\n                    up--;\n                    aBlackPointFoundOnBorder = true;\n                    atLeastOneBlackPointFoundOnTop = true;\n                }\n                else if (!atLeastOneBlackPointFoundOnTop) {\n                    up--;\n                }\n            }\n            if (up < 0) {\n                sizeExceeded = true;\n                break;\n            }\n            if (aBlackPointFoundOnBorder) {\n                atLeastOneBlackPointFoundOnBorder = true;\n            }\n        }\n        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n            var maxSize = right - left;\n            var z = null;\n            for (var i = 1; z === null && i < maxSize; i++) {\n                z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n            }\n            if (z == null) {\n                throw new NotFoundException_1.default();\n            }\n            var t = null;\n            // go down right\n            for (var i = 1; t === null && i < maxSize; i++) {\n                t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n            }\n            if (t == null) {\n                throw new NotFoundException_1.default();\n            }\n            var x = null;\n            // go down left\n            for (var i = 1; x === null && i < maxSize; i++) {\n                x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n            }\n            if (x == null) {\n                throw new NotFoundException_1.default();\n            }\n            var y = null;\n            // go up left\n            for (var i = 1; y === null && i < maxSize; i++) {\n                y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n            }\n            if (y == null) {\n                throw new NotFoundException_1.default();\n            }\n            return this.centerEdges(y, z, x, t);\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {\n        var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));\n        var xStep = (bX - aX) / dist;\n        var yStep = (bY - aY) / dist;\n        var image = this.image;\n        for (var i = 0; i < dist; i++) {\n            var x = MathUtils_1.default.round(aX + i * xStep);\n            var y = MathUtils_1.default.round(aY + i * yStep);\n            if (image.get(x, y)) {\n                return new ResultPoint_1.default(x, y);\n            }\n        }\n        return null;\n    };\n    /**\n     * recenters the points of a constant distance towards the center\n     *\n     * @param y bottom most point\n     * @param z left most point\n     * @param x right most point\n     * @param t top most point\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\n     *         region. The first and last points are opposed on the diagonal, as\n     *         are the second and third. The first point will be the topmost\n     *         point and the last, the bottommost. The second point will be\n     *         leftmost and the third, the rightmost\n     */\n    WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\n        //\n        //       t            t\n        //  z                      x\n        //        x    OR    z\n        //   y                    y\n        //\n        var yi = y.getX();\n        var yj = y.getY();\n        var zi = z.getX();\n        var zj = z.getY();\n        var xi = x.getX();\n        var xj = x.getY();\n        var ti = t.getX();\n        var tj = t.getY();\n        var CORR = WhiteRectangleDetector.CORR;\n        if (yi < this.width / 2.0) {\n            return [\n                new ResultPoint_1.default(ti - CORR, tj + CORR),\n                new ResultPoint_1.default(zi + CORR, zj + CORR),\n                new ResultPoint_1.default(xi - CORR, xj - CORR),\n                new ResultPoint_1.default(yi + CORR, yj - CORR)\n            ];\n        }\n        else {\n            return [\n                new ResultPoint_1.default(ti + CORR, tj + CORR),\n                new ResultPoint_1.default(zi + CORR, zj - CORR),\n                new ResultPoint_1.default(xi - CORR, xj + CORR),\n                new ResultPoint_1.default(yi - CORR, yj - CORR)\n            ];\n        }\n    };\n    /**\n     * Determines whether a segment contains a black point\n     *\n     * @param a          min value of the scanned coordinate\n     * @param b          max value of the scanned coordinate\n     * @param fixed      value of fixed coordinate\n     * @param horizontal set to true if scan must be horizontal, false if vertical\n     * @return true if a black point has been found, else false.\n     */\n    WhiteRectangleDetector.prototype.containsBlackPoint = function (a /*int*/, b /*int*/, fixed /*int*/, horizontal) {\n        var image = this.image;\n        if (horizontal) {\n            for (var x = a; x <= b; x++) {\n                if (image.get(x, fixed)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            for (var y = a; y <= b; y++) {\n                if (image.get(fixed, y)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    WhiteRectangleDetector.INIT_SIZE = 10;\n    WhiteRectangleDetector.CORR = 1;\n    return WhiteRectangleDetector;\n}());\nexports.default = WhiteRectangleDetector;\n//# sourceMappingURL=WhiteRectangleDetector.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","ResultPoint_1","MathUtils_1","NotFoundException_1","WhiteRectangleDetector","image","initSize","x","y","height","getHeight","width","getWidth","undefined","INIT_SIZE","halfsize","leftInit","rightInit","upInit","downInit","default","prototype","detect","WhiteRectangleDetector.prototype.detect","left","right","up","down","sizeExceeded","aBlackPointFoundOnBorder","atLeastOneBlackPointFoundOnBorder","atLeastOneBlackPointFoundOnRight","atLeastOneBlackPointFoundOnBottom","atLeastOneBlackPointFoundOnLeft","atLeastOneBlackPointFoundOnTop","rightBorderNotWhite","containsBlackPoint","bottomBorderNotWhite","leftBorderNotWhite","topBorderNotWhite","maxSize","z","i","getBlackPointOnSegment","t","centerEdges","WhiteRectangleDetector.prototype.getBlackPointOnSegment","aX","aY","bX","bY","dist","round","distance","xStep","yStep","get","WhiteRectangleDetector.prototype.centerEdges","yi","getX","yj","getY","zi","zj","xi","xj","ti","tj","CORR","WhiteRectangleDetector.prototype.containsBlackPoint","a","b","fixed","horizontal"]
}
