{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$Decoder.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/decoder/Decoder.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$Decoder\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode.decoder {*/\nvar ChecksumException_1 = require(\"../../ChecksumException\");\nvar BitMatrix_1 = require(\"../../common/BitMatrix\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\nvar BitMatrixParser_1 = require(\"./BitMatrixParser\");\nvar DataBlock_1 = require(\"./DataBlock\");\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\nvar QRCodeDecoderMetaData_1 = require(\"./QRCodeDecoderMetaData\");\n/*import java.util.Map;*/\n/**\n * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\n * the QR Code from an image.</p>\n *\n * @author Sean Owen\n */\nvar Decoder = /** @class */ (function () {\n    function Decoder() {\n        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);\n    }\n    // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n    //   return decode(image, null)\n    // }\n    /**\n     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\n     * \"true\" is taken to mean a black module.</p>\n     *\n     * @param image booleans representing white/black QR Code modules\n     * @param hints decoding hints that should be used to influence decoding\n     * @return text and bytes encoded within the QR Code\n     * @throws FormatException if the QR Code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.decodeBooleanArray = function (image, hints) {\n        return this.decodeBitMatrix(BitMatrix_1.default.parseFromBooleanArray(image), hints);\n    };\n    // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n    //   return decode(bits, null)\n    // }\n    /**\n     * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\n     *\n     * @param bits booleans representing white/black QR Code modules\n     * @param hints decoding hints that should be used to influence decoding\n     * @return text and bytes encoded within the QR Code\n     * @throws FormatException if the QR Code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.decodeBitMatrix = function (bits, hints) {\n        // Construct a parser and read version, error-correction level\n        var parser = new BitMatrixParser_1.default(bits);\n        var ex = null;\n        try {\n            return this.decodeBitMatrixParser(parser, hints);\n        }\n        catch (e /*: FormatException, ChecksumException*/) {\n            ex = e;\n        }\n        try {\n            // Revert the bit matrix\n            parser.remask();\n            // Will be attempting a mirrored reading of the version and format info.\n            parser.setMirror(true);\n            // Preemptively read the version.\n            parser.readVersion();\n            // Preemptively read the format information.\n            parser.readFormatInformation();\n            /*\n             * Since we're here, this means we have successfully detected some kind\n             * of version and format information when mirrored. This is a good sign,\n             * that the QR code may be mirrored, and we should try once more with a\n             * mirrored content.\n             */\n            // Prepare for a mirrored reading.\n            parser.mirror();\n            var result = this.decodeBitMatrixParser(parser, hints);\n            // Success! Notify the caller that the code was mirrored.\n            result.setOther(new QRCodeDecoderMetaData_1.default(true));\n            return result;\n        }\n        catch (e /*FormatException | ChecksumException*/) {\n            // Throw the exception from the original reading\n            if (ex !== null) {\n                throw ex;\n            }\n            throw e;\n        }\n    };\n    Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {\n        var e_1, _a, e_2, _b;\n        var version = parser.readVersion();\n        var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n        // Read codewords\n        var codewords = parser.readCodewords();\n        // Separate into data blocks\n        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel);\n        // Count total number of data bytes\n        var totalBytes = 0;\n        try {\n            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\n                var dataBlock = dataBlocks_1_1.value;\n                totalBytes += dataBlock.getNumDataCodewords();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var resultBytes = new Uint8Array(totalBytes);\n        var resultOffset = 0;\n        try {\n            // Error-correct and copy data blocks together into a stream of bytes\n            for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {\n                var dataBlock = dataBlocks_2_1.value;\n                var codewordBytes = dataBlock.getCodewords();\n                var numDataCodewords = dataBlock.getNumDataCodewords();\n                this.correctErrors(codewordBytes, numDataCodewords);\n                for (var i = 0; i < numDataCodewords; i++) {\n                    resultBytes[resultOffset++] = codewordBytes[i];\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        // Decode the contents of that stream of bytes\n        return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);\n    };\n    /**\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n     * correct the errors in-place using Reed-Solomon error correction.</p>\n     *\n     * @param codewordBytes data and error correction codewords\n     * @param numDataCodewords number of codewords that are data bytes\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {\n        // const numCodewords = codewordBytes.length;\n        // First read into an array of ints\n        var codewordsInts = new Int32Array(codewordBytes);\n        // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n        // const codewordsInts = new Int32Array(numCodewords)\n        // for (let i = 0; i < numCodewords; i++) {\n        //   codewordsInts[i] = codewordBytes[i] & 0xFF\n        // }\n        try {\n            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n        }\n        catch (ignored /*: ReedSolomonException*/) {\n            throw new ChecksumException_1.default();\n        }\n        // Copy back into array of bytes -- only need to worry about the bytes that were data\n        // We don't care about errors in the error-correction codewords\n        for (var i = 0; i < numDataCodewords; i++) {\n            codewordBytes[i] = /*(byte) */ codewordsInts[i];\n        }\n    };\n    return Decoder;\n}());\nexports.default = Decoder;\n//# sourceMappingURL=Decoder.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","Object","defineProperty","ChecksumException_1","BitMatrix_1","GenericGF_1","ReedSolomonDecoder_1","BitMatrixParser_1","DataBlock_1","DecodedBitStreamParser_1","QRCodeDecoderMetaData_1","Decoder","rsDecoder","default","QR_CODE_FIELD_256","prototype","decodeBooleanArray","Decoder.prototype.decodeBooleanArray","image","hints","decodeBitMatrix","parseFromBooleanArray","Decoder.prototype.decodeBitMatrix","bits","parser","decodeBitMatrixParser","e","ex","remask","setMirror","readVersion","readFormatInformation","mirror","result","setOther","Decoder.prototype.decodeBitMatrixParser","_a","_b","version","ecLevel","getErrorCorrectionLevel","codewords","readCodewords","dataBlocks","getDataBlocks","totalBytes","dataBlocks_1","dataBlocks_1_1","dataBlock","getNumDataCodewords","e_1_1","e_1","error","return","resultBytes","Uint8Array","resultOffset","dataBlocks_2","dataBlocks_2_1","codewordBytes","getCodewords","numDataCodewords","correctErrors","e_2_1","e_2","decode","Decoder.prototype.correctErrors","codewordsInts","Int32Array","ignored"]
}
