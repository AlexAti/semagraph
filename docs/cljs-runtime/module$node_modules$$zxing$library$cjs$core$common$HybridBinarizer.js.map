{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$common$HybridBinarizer.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/common/HybridBinarizer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$common$HybridBinarizer\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GlobalHistogramBinarizer_1 = require(\"./GlobalHistogramBinarizer\");\nvar BitMatrix_1 = require(\"./BitMatrix\");\n/**\n * This class implements a local thresholding algorithm, which while slower than the\n * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\n * high frequency images of barcodes with black data on white backgrounds. For this application,\n * it does a much better job than a global blackpoint with severe shadows and gradients.\n * However it tends to produce artifacts on lower frequency images and is therefore not\n * a good general purpose binarizer for uses outside ZXing.\n *\n * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\n * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\n * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\n * but for now it was not a win to use local blocks for 1D.\n *\n * This Binarizer is the default for the unit tests and the recommended class for library users.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar HybridBinarizer = /** @class */ (function (_super) {\n    __extends(HybridBinarizer, _super);\n    function HybridBinarizer(source) {\n        var _this = _super.call(this, source) || this;\n        _this.matrix = null;\n        return _this;\n    }\n    /**\n     * Calculates the final BitMatrix once for all requests. This could be called once from the\n     * constructor instead, but there are some advantages to doing it lazily, such as making\n     * profiling easier, and not doing heavy lifting when callers don't expect it.\n     */\n    /*@Override*/\n    HybridBinarizer.prototype.getBlackMatrix = function () {\n        if (this.matrix !== null) {\n            return this.matrix;\n        }\n        var source = this.getLuminanceSource();\n        var width = source.getWidth();\n        var height = source.getHeight();\n        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n            var luminances = source.getMatrix();\n            var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n            if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                subWidth++;\n            }\n            var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n            if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                subHeight++;\n            }\n            var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n            var newMatrix = new BitMatrix_1.default(width, height);\n            HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n            this.matrix = newMatrix;\n        }\n        else {\n            // If the image is too small, fall back to the global histogram approach.\n            this.matrix = _super.prototype.getBlackMatrix.call(this);\n        }\n        return this.matrix;\n    };\n    /*@Override*/\n    HybridBinarizer.prototype.createBinarizer = function (source) {\n        return new HybridBinarizer(source);\n    };\n    /**\n     * For each block in the image, calculate the average black point using a 5x5 grid\n     * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n     * on the last pixels in the row/column which are also used in the previous block).\n     */\n    HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {\n        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n        for (var y = 0; y < subHeight; y++) {\n            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n            if (yoffset > maxYOffset) {\n                yoffset = maxYOffset;\n            }\n            var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);\n            for (var x = 0; x < subWidth; x++) {\n                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (xoffset > maxXOffset) {\n                    xoffset = maxXOffset;\n                }\n                var left = HybridBinarizer.cap(x, 2, subWidth - 3);\n                var sum = 0;\n                for (var z = -2; z <= 2; z++) {\n                    var blackRow = blackPoints[top_1 + z];\n                    sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n                }\n                var average = sum / 25;\n                HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n            }\n        }\n    };\n    HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {\n        return value < min ? min : value > max ? max : value;\n    };\n    /**\n     * Applies a single threshold to a block of pixels.\n     */\n    HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {\n        for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\n            for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\n                // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n                if ((luminances[offset + x] & 0xFF) <= threshold) {\n                    matrix.set(xoffset + x, yoffset + y);\n                }\n            }\n        }\n    };\n    /**\n     * Calculates a single black point for each block of pixels and saves it away.\n     * See the following thread for a discussion of this algorithm:\n     *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\n     */\n    HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {\n        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n        // tslint:disable-next-line:whitespace\n        var blackPoints = new Array(subHeight); // subWidth\n        for (var y = 0; y < subHeight; y++) {\n            blackPoints[y] = new Int32Array(subWidth);\n            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n            if (yoffset > maxYOffset) {\n                yoffset = maxYOffset;\n            }\n            for (var x = 0; x < subWidth; x++) {\n                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (xoffset > maxXOffset) {\n                    xoffset = maxXOffset;\n                }\n                var sum = 0;\n                var min = 0xFF;\n                var max = 0;\n                for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                    for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                        var pixel = luminances[offset + xx] & 0xFF;\n                        sum += pixel;\n                        // still looking for good contrast\n                        if (pixel < min) {\n                            min = pixel;\n                        }\n                        if (pixel > max) {\n                            max = pixel;\n                        }\n                    }\n                    // short-circuit min/max tests once dynamic range is met\n                    if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                        // finish the rest of the rows quickly\n                        for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                            for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                                sum += luminances[offset + xx] & 0xFF;\n                            }\n                        }\n                    }\n                }\n                // The default estimate is the average of the values in the block.\n                var average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);\n                if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                    // If variation within the block is low, assume this is a block with only light or only\n                    // dark pixels. In that case we do not want to use the average, as it would divide this\n                    // low contrast area into black and white pixels, essentially creating data out of noise.\n                    //\n                    // The default assumption is that the block is light/background. Since no estimate for\n                    // the level of dark pixels exists locally, use half the min for the block.\n                    average = min / 2;\n                    if (y > 0 && x > 0) {\n                        // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n                        // the pixels in this block to the previously calculated black points. This is based on\n                        // the fact that dark barcode symbology is always surrounded by some amount of light\n                        // background for which reasonable black point estimates were made. The bp estimated at\n                        // the boundaries is used for the interior.\n                        // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n                        var averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;\n                        if (min < averageNeighborBlackPoint) {\n                            average = averageNeighborBlackPoint;\n                        }\n                    }\n                }\n                blackPoints[y][x] = average;\n            }\n        }\n        return blackPoints;\n    };\n    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n    // So this is the smallest dimension in each axis we can accept.\n    HybridBinarizer.BLOCK_SIZE_POWER = 3;\n    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n    return HybridBinarizer;\n}(GlobalHistogramBinarizer_1.default));\nexports.default = HybridBinarizer;\n//# sourceMappingURL=HybridBinarizer.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","GlobalHistogramBinarizer_1","BitMatrix_1","HybridBinarizer","_super","source","_this","call","matrix","getBlackMatrix","HybridBinarizer.prototype.getBlackMatrix","getLuminanceSource","width","getWidth","height","getHeight","MINIMUM_DIMENSION","luminances","getMatrix","subWidth","BLOCK_SIZE_POWER","BLOCK_SIZE_MASK","subHeight","blackPoints","calculateBlackPoints","newMatrix","default","calculateThresholdForBlock","createBinarizer","HybridBinarizer.prototype.createBinarizer","HybridBinarizer.calculateThresholdForBlock","maxYOffset","BLOCK_SIZE","maxXOffset","y","yoffset","top_1","cap","x","xoffset","left","sum","z","blackRow","thresholdBlock","HybridBinarizer.cap","min","max","HybridBinarizer.thresholdBlock","threshold","stride","offset","set","HybridBinarizer.calculateBlackPoints","Int32Array","yy","xx","pixel","MIN_DYNAMIC_RANGE","average","averageNeighborBlackPoint"]
}
