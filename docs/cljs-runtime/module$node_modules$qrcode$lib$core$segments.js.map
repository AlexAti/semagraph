{
"version":3,
"file":"module$node_modules$qrcode$lib$core$segments.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/qrcode/lib/core/segments.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$qrcode$lib$core$segments\"] = function(global,require,module,exports) {\nconst Mode = require('./mode')\nconst NumericData = require('./numeric-data')\nconst AlphanumericData = require('./alphanumeric-data')\nconst ByteData = require('./byte-data')\nconst KanjiData = require('./kanji-data')\nconst Regex = require('./regex')\nconst Utils = require('./utils')\nconst dijkstra = require('dijkstrajs')\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  const segments = []\n  let result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  let byteSegs\n  let kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  const nodes = []\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  const table = {}\n  const graph = { start: {} }\n  let prevNodeIds = ['start']\n\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeGroup = nodes[i]\n    const currentNodeIds = []\n\n    for (let j = 0; j < nodeGroup.length; j++) {\n      const node = nodeGroup[j]\n      const key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (let n = 0; n < prevNodeIds.length; n++) {\n        const prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (let n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]].end = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  let mode\n  const bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  const nodes = buildNodes(segs)\n  const graph = buildGraph(nodes, version)\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  const optimizedSegs = []\n  for (let i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","getSegments","regex","mode","str","segments","result","exec","push","data","index","length","getSegmentsFromString","dataStr","numSegs","Regex","NUMERIC","Mode","alphaNumSegs","ALPHANUMERIC","byteSegs","Utils","isKanjiModeEnabled","BYTE","kanjiSegs","KANJI","BYTE_KANJI","concat","segs","sort","s1","s2","map","obj","getSegmentBitsLength","NumericData","getBitsLength","AlphanumericData","KanjiData","ByteData","mergeSegments","reduce","acc","curr","prevSeg","buildSingleSegment","modesHint","bestMode","getBestModeForData","from","bit","Error","toString","dijkstra","fromArray","exports.fromArray","array","seg","fromString","exports.fromString","version","nodes","i","unescape","encodeURIComponent","table","graph","start","prevNodeIds","nodeGroup","currentNodeIds","j","node","key","lastCount","n","prevNodeId","getCharCountIndicator","end","path","find_path","optimizedSegs","rawSplit","exports.rawSplit"]
}
