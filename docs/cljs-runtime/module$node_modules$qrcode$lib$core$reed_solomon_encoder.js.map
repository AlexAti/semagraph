{
"version":3,
"file":"module$node_modules$qrcode$lib$core$reed_solomon_encoder.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,wDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGrHC,QAASA,mBAAmB,CAACC,MAAD,CAAS,CACnC,IAAKC,CAAAA,OAAL,CAAeC,IAAAA,EAGf,EAFA,IAAKF,CAAAA,MAEL,CAFcA,MAEd,GAAiB,IAAKG,CAAAA,UAAL,CAAgB,IAAKH,CAAAA,MAArB,CAJkB,CAFrC,MAAMI,WAAaR,OAAA,CAAQ,gDAAR,CAenBG,mBAAmBM,CAAAA,SAAUF,CAAAA,UAA7B,CAA0CG,QAAoB,CAACN,MAAD,CAAS,CAErE,IAAKA,CAAAA,MAAL,CAAcA,MACd,KAAKC,CAAAA,OAAL,CAAeG,UAAWG,CAAAA,oBAAX,CAAgC,IAAKP,CAAAA,MAArC,CAHsD,CAYvED,mBAAmBM,CAAAA,SAAUG,CAAAA,MAA7B,CAAsCC,QAAgB,CAACC,IAAD,CAAO,CAC3D,GAAI,CAAC,IAAKT,CAAAA,OAAV,CACE,KAAUU,MAAJ,CAAU,yBAAV,CAAN;AAKF,IAAMC,WAAa,IAAIC,UAAJ,CAAeH,IAAKI,CAAAA,MAApB,CAA6B,IAAKd,CAAAA,MAAlC,CACnBY,WAAWG,CAAAA,GAAX,CAAeL,IAAf,CAIMM,KAAAA,CAAYZ,UAAWa,CAAAA,GAAX,CAAeL,UAAf,CAA2B,IAAKX,CAAAA,OAAhC,CAKZiB,WAAAA,CAAQ,IAAKlB,CAAAA,MAAbkB,CAAsBF,IAAUF,CAAAA,MACtC,IAAY,CAAZ,CAAII,UAAJ,CAAe,CACb,MAAMC,KAAO,IAAIN,UAAJ,CAAe,IAAKb,CAAAA,MAApB,CACbmB,KAAKJ,CAAAA,GAAL,CAASC,IAAT,CAAoBE,UAApB,CAEA,OAAOC,KAJM,CAOf,MAAOH,KAzBoD,CA4B7DnB,OAAOC,CAAAA,OAAP,CAAiBC,kBAxDoG;",
"sources":["node_modules/qrcode/lib/core/reed-solomon-encoder.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$qrcode$lib$core$reed_solomon_encoder\"] = function(global,require,module,exports) {\nconst Polynomial = require('./polynomial')\n\nfunction ReedSolomonEncoder (degree) {\n  this.genPoly = undefined\n  this.degree = degree\n\n  if (this.degree) this.initialize(this.degree)\n}\n\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize (degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree\n  this.genPoly = Polynomial.generateECPolynomial(this.degree)\n}\n\n/**\n * Encodes a chunk of data\n *\n * @param  {Uint8Array} data Buffer containing input data\n * @return {Uint8Array}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode (data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized')\n  }\n\n  // Calculate EC for this data block\n  // extends data size to data+genPoly size\n  const paddedData = new Uint8Array(data.length + this.degree)\n  paddedData.set(data)\n\n  // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n  const remainder = Polynomial.mod(paddedData, this.genPoly)\n\n  // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n  const start = this.degree - remainder.length\n  if (start > 0) {\n    const buff = new Uint8Array(this.degree)\n    buff.set(remainder, start)\n\n    return buff\n  }\n\n  return remainder\n}\n\nmodule.exports = ReedSolomonEncoder\n\n};"],
"names":["shadow$provide","global","require","module","exports","ReedSolomonEncoder","degree","genPoly","undefined","initialize","Polynomial","prototype","ReedSolomonEncoder.prototype.initialize","generateECPolynomial","encode","ReedSolomonEncoder.prototype.encode","data","Error","paddedData","Uint8Array","length","set","remainder","mod","start","buff"]
}
