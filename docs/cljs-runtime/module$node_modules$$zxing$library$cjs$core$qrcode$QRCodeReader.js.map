{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$QRCodeReader.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/QRCodeReader.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$QRCodeReader\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode {*/\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar Result_1 = require(\"../Result\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\n// import DetectorResult from '../common/DetectorResult';\nvar Decoder_1 = require(\"./decoder/Decoder\");\nvar QRCodeDecoderMetaData_1 = require(\"./decoder/QRCodeDecoderMetaData\");\nvar Detector_1 = require(\"./detector/Detector\");\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * This implementation can detect and decode QR Codes in an image.\n *\n * @author Sean Owen\n */\nvar QRCodeReader = /** @class */ (function () {\n    function QRCodeReader() {\n        this.decoder = new Decoder_1.default();\n    }\n    QRCodeReader.prototype.getDecoder = function () {\n        return this.decoder;\n    };\n    /**\n     * Locates and decodes a QR code in an image.\n     *\n     * @return a representing: string the content encoded by the QR code\n     * @throws NotFoundException if a QR code cannot be found\n     * @throws FormatException if a QR code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    /*@Override*/\n    // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n    //   return this.decode(image, null)\n    // }\n    /*@Override*/\n    QRCodeReader.prototype.decode = function (image, hints) {\n        var decoderResult;\n        var points;\n        if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {\n            var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n            decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n            points = QRCodeReader.NO_POINTS;\n        }\n        else {\n            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);\n            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n            points = detectorResult.getPoints();\n        }\n        // If the code was mirrored: swap the bottom-left and the top-right points.\n        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {\n            decoderResult.getOther().applyMirroredCorrection(points);\n        }\n        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);\n        var byteSegments = decoderResult.getByteSegments();\n        if (byteSegments !== null) {\n            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n        }\n        var ecLevel = decoderResult.getECLevel();\n        if (ecLevel !== null) {\n            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n        }\n        if (decoderResult.hasStructuredAppend()) {\n            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n        }\n        return result;\n    };\n    /*@Override*/\n    QRCodeReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n     * which contains only an unrotated, unskewed, image of a code, with some white border\n     * around it. This is a specialized method that works exceptionally fast in this special\n     * case.\n     *\n     * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\n     */\n    QRCodeReader.extractPureBits = function (image) {\n        var leftTopBlack = image.getTopLeftOnBit();\n        var rightBottomBlack = image.getBottomRightOnBit();\n        if (leftTopBlack === null || rightBottomBlack === null) {\n            throw new NotFoundException_1.default();\n        }\n        var moduleSize = this.moduleSize(leftTopBlack, image);\n        var top = leftTopBlack[1];\n        var bottom = rightBottomBlack[1];\n        var left = leftTopBlack[0];\n        var right = rightBottomBlack[0];\n        // Sanity check!\n        if (left >= right || top >= bottom) {\n            throw new NotFoundException_1.default();\n        }\n        if (bottom - top !== right - left) {\n            // Special case, where bottom-right module wasn't black so we found something else in the last row\n            // Assume it's a square, so use height as the width\n            right = left + (bottom - top);\n            if (right >= image.getWidth()) {\n                // Abort if that would not make sense -- off image\n                throw new NotFoundException_1.default();\n            }\n        }\n        var matrixWidth = Math.round((right - left + 1) / moduleSize);\n        var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\n            throw new NotFoundException_1.default();\n        }\n        if (matrixHeight !== matrixWidth) {\n            // Only possibly decode square regions\n            throw new NotFoundException_1.default();\n        }\n        // Push in the \"border\" by half the module width so that we start\n        // sampling in the middle of the module. Just in case the image is a\n        // little off, this will help recover.\n        var nudge = /*(int) */ Math.floor(moduleSize / 2.0);\n        top += nudge;\n        left += nudge;\n        // But careful that this does not sample off the edge\n        // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n        // This is positive by how much the inner x loop below would be too large\n        var nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;\n        if (nudgedTooFarRight > 0) {\n            if (nudgedTooFarRight > nudge) {\n                // Neither way fits; abort\n                throw new NotFoundException_1.default();\n            }\n            left -= nudgedTooFarRight;\n        }\n        // See logic above\n        var nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n        if (nudgedTooFarDown > 0) {\n            if (nudgedTooFarDown > nudge) {\n                // Neither way fits; abort\n                throw new NotFoundException_1.default();\n            }\n            top -= nudgedTooFarDown;\n        }\n        // Now just read off the bits\n        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n        for (var y = 0; y < matrixHeight; y++) {\n            var iOffset = top + /*(int) */ Math.floor(y * moduleSize);\n            for (var x = 0; x < matrixWidth; x++) {\n                if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {\n                    bits.set(x, y);\n                }\n            }\n        }\n        return bits;\n    };\n    QRCodeReader.moduleSize = function (leftTopBlack, image) {\n        var height = image.getHeight();\n        var width = image.getWidth();\n        var x = leftTopBlack[0];\n        var y = leftTopBlack[1];\n        var inBlack = true;\n        var transitions = 0;\n        while (x < width && y < height) {\n            if (inBlack !== image.get(x, y)) {\n                if (++transitions === 5) {\n                    break;\n                }\n                inBlack = !inBlack;\n            }\n            x++;\n            y++;\n        }\n        if (x === width || y === height) {\n            throw new NotFoundException_1.default();\n        }\n        return (x - leftTopBlack[0]) / 7.0;\n    };\n    QRCodeReader.NO_POINTS = new Array();\n    return QRCodeReader;\n}());\nexports.default = QRCodeReader;\n//# sourceMappingURL=QRCodeReader.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","BarcodeFormat_1","BitMatrix_1","DecodeHintType_1","NotFoundException_1","Result_1","ResultMetadataType_1","Decoder_1","QRCodeDecoderMetaData_1","Detector_1","QRCodeReader","decoder","default","prototype","getDecoder","QRCodeReader.prototype.getDecoder","decode","QRCodeReader.prototype.decode","image","hints","undefined","get","PURE_BARCODE","bits","extractPureBits","getBlackMatrix","decoderResult","decodeBitMatrix","points","NO_POINTS","detectorResult","detect","getBits","getPoints","getOther","applyMirroredCorrection","result","getText","getRawBytes","QR_CODE","byteSegments","getByteSegments","putMetadata","BYTE_SEGMENTS","ecLevel","getECLevel","ERROR_CORRECTION_LEVEL","hasStructuredAppend","STRUCTURED_APPEND_SEQUENCE","getStructuredAppendSequenceNumber","STRUCTURED_APPEND_PARITY","getStructuredAppendParity","reset","QRCodeReader.prototype.reset","QRCodeReader.extractPureBits","leftTopBlack","getTopLeftOnBit","rightBottomBlack","getBottomRightOnBit","moduleSize","top","bottom","left","right","getWidth","matrixWidth","Math","round","matrixHeight","nudge","floor","nudgedTooFarRight","nudgedTooFarDown","y","iOffset","x","set","QRCodeReader.moduleSize","height","getHeight","width","inBlack","transitions"]
}
