{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$oned$AbstractUPCEANReader.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/oned/AbstractUPCEANReader.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$oned$AbstractUPCEANReader\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OneDReader_1 = require(\"./OneDReader\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar FormatException_1 = require(\"../FormatException\");\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar AbstractUPCEANReader = /** @class */ (function (_super) {\n    __extends(AbstractUPCEANReader, _super);\n    function AbstractUPCEANReader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.decodeRowStringBuffer = '';\n        return _this;\n    }\n    // private final UPCEANExtensionSupport extensionReader;\n    // private final EANManufacturerOrgSupport eanManSupport;\n    /*\n    protected UPCEANReader() {\n        decodeRowStringBuffer = new StringBuilder(20);\n        extensionReader = new UPCEANExtensionSupport();\n        eanManSupport = new EANManufacturerOrgSupport();\n    }\n    */\n    AbstractUPCEANReader.findStartGuardPattern = function (row) {\n        var foundStart = false;\n        var startRange;\n        var nextStart = 0;\n        var counters = Int32Array.from([0, 0, 0]);\n        while (!foundStart) {\n            counters = Int32Array.from([0, 0, 0]);\n            startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n            var start = startRange[0];\n            nextStart = startRange[1];\n            var quietStart = start - (nextStart - start);\n            if (quietStart >= 0) {\n                foundStart = row.isRange(quietStart, start, false);\n            }\n        }\n        return startRange;\n    };\n    AbstractUPCEANReader.checkChecksum = function (s) {\n        return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n    };\n    AbstractUPCEANReader.checkStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        if (length === 0)\n            return false;\n        var check = parseInt(s.charAt(length - 1), 10);\n        return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n    };\n    AbstractUPCEANReader.getStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        var sum = 0;\n        for (var i = length - 1; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        sum *= 3;\n        for (var i = length - 2; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        return (1000 - sum) % 10;\n    };\n    AbstractUPCEANReader.decodeEnd = function (row, endStart) {\n        return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n    };\n    /**\n     * @throws NotFoundException\n     */\n    AbstractUPCEANReader.findGuardPatternWithoutCounters = function (row, rowOffset, whiteFirst, pattern) {\n        return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));\n    };\n    /**\n     * @param row row of black/white values to search\n     * @param rowOffset position to start search\n     * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...\n     * pixel counts, otherwise, it is interpreted as black/white/black/...\n     * @param pattern pattern of counts of number of black and white pixels that are being\n     * searched for as a pattern\n     * @param counters array of counters, as long as pattern, to re-use\n     * @return start/end horizontal offset of guard pattern, as an array of two ints\n     * @throws NotFoundException if pattern is not found\n     */\n    AbstractUPCEANReader.findGuardPattern = function (row, rowOffset, whiteFirst, pattern, counters) {\n        var width = row.getSize();\n        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        var patternLength = pattern.length;\n        var isWhite = whiteFirst;\n        for (var x = rowOffset; x < width; x++) {\n            if (row.get(x) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n                        return Int32Array.from([patternStart, x]);\n                    }\n                    patternStart += counters[0] + counters[1];\n                    var slice = counters.slice(2, counters.length - 1);\n                    for (var i = 0; i < counterPosition - 1; i++) {\n                        counters[i] = slice[i];\n                    }\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    AbstractUPCEANReader.decodeDigit = function (row, counters, rowOffset, patterns) {\n        this.recordPattern(row, rowOffset, counters);\n        var bestVariance = this.MAX_AVG_VARIANCE;\n        var bestMatch = -1;\n        var max = patterns.length;\n        for (var i = 0; i < max; i++) {\n            var pattern = patterns[i];\n            var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n            if (variance < bestVariance) {\n                bestVariance = variance;\n                bestMatch = i;\n            }\n        }\n        if (bestMatch >= 0) {\n            return bestMatch;\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    // These two values are critical for determining how permissive the decoding will be.\n    // We've arrived at these values through a lot of trial and error. Setting them any higher\n    // lets false positives creep in quickly.\n    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    /**\n     * Start/end guard pattern.\n     */\n    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);\n    /**\n     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\n     */\n    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);\n    /**\n     * end guard pattern.\n     */\n    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n    /**\n     * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\n     */\n    AbstractUPCEANReader.L_PATTERNS = [\n        Int32Array.from([3, 2, 1, 1]),\n        Int32Array.from([2, 2, 2, 1]),\n        Int32Array.from([2, 1, 2, 2]),\n        Int32Array.from([1, 4, 1, 1]),\n        Int32Array.from([1, 1, 3, 2]),\n        Int32Array.from([1, 2, 3, 1]),\n        Int32Array.from([1, 1, 1, 4]),\n        Int32Array.from([1, 3, 1, 2]),\n        Int32Array.from([1, 2, 1, 3]),\n        Int32Array.from([3, 1, 1, 2]),\n    ];\n    return AbstractUPCEANReader;\n}(OneDReader_1.default));\nexports.default = AbstractUPCEANReader;\n//# sourceMappingURL=AbstractUPCEANReader.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","OneDReader_1","NotFoundException_1","FormatException_1","AbstractUPCEANReader","_super","_this","apply","arguments","decodeRowStringBuffer","findStartGuardPattern","AbstractUPCEANReader.findStartGuardPattern","row","foundStart","nextStart","Int32Array","from","counters","startRange","findGuardPattern","START_END_PATTERN","start","quietStart","isRange","checkChecksum","AbstractUPCEANReader.checkChecksum","s","checkStandardUPCEANChecksum","AbstractUPCEANReader.checkStandardUPCEANChecksum","length","check","parseInt","charAt","getStandardUPCEANChecksum","substring","AbstractUPCEANReader.getStandardUPCEANChecksum","sum","i","digit","charCodeAt","default","decodeEnd","AbstractUPCEANReader.decodeEnd","endStart","fill","findGuardPatternWithoutCounters","AbstractUPCEANReader.findGuardPatternWithoutCounters","rowOffset","whiteFirst","pattern","AbstractUPCEANReader.findGuardPattern","width","getSize","getNextUnset","getNextSet","counterPosition","patternStart","patternLength","x","get","isWhite","patternMatchVariance","MAX_INDIVIDUAL_VARIANCE","MAX_AVG_VARIANCE","slice","decodeDigit","AbstractUPCEANReader.decodeDigit","patterns","recordPattern","bestVariance","bestMatch","max","variance","MIDDLE_PATTERN","END_PATTERN","L_PATTERNS"]
}
