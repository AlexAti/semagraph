{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$encoder$MaskUtil.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/encoder/MaskUtil.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$encoder$MaskUtil\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/**\n * @author Satoru Takabayashi\n * @author Daniel Switkin\n * @author Sean Owen\n */\nvar MaskUtil = /** @class */ (function () {\n    function MaskUtil() {\n        // do nothing\n    }\n    /**\n     * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and\n     * give penalty to them. Example: 00000 or 11111.\n     */\n    MaskUtil.applyMaskPenaltyRule1 = function (matrix) {\n        return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);\n    };\n    /**\n     * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give\n     * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a\n     * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.\n     */\n    MaskUtil.applyMaskPenaltyRule2 = function (matrix) {\n        var penalty = 0;\n        var array = matrix.getArray();\n        var width = matrix.getWidth();\n        var height = matrix.getHeight();\n        for (var y = 0; y < height - 1; y++) {\n            var arrayY = array[y];\n            for (var x = 0; x < width - 1; x++) {\n                var value = arrayY[x];\n                if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {\n                    penalty++;\n                }\n            }\n        }\n        return MaskUtil.N2 * penalty;\n    };\n    /**\n     * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4\n     * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we\n     * find patterns like 000010111010000, we give penalty once.\n     */\n    MaskUtil.applyMaskPenaltyRule3 = function (matrix) {\n        var numPenalties = 0;\n        var array = matrix.getArray();\n        var width = matrix.getWidth();\n        var height = matrix.getHeight();\n        for (var y = 0; y < height; y++) {\n            for (var x = 0; x < width; x++) {\n                var arrayY = array[y]; // We can at least optimize this access\n                if (x + 6 < width &&\n                    arrayY[x] === 1 &&\n                    arrayY[x + 1] === 0 &&\n                    arrayY[x + 2] === 1 &&\n                    arrayY[x + 3] === 1 &&\n                    arrayY[x + 4] === 1 &&\n                    arrayY[x + 5] === 0 &&\n                    arrayY[x + 6] === 1 &&\n                    (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {\n                    numPenalties++;\n                }\n                if (y + 6 < height &&\n                    array[y][x] === 1 &&\n                    array[y + 1][x] === 0 &&\n                    array[y + 2][x] === 1 &&\n                    array[y + 3][x] === 1 &&\n                    array[y + 4][x] === 1 &&\n                    array[y + 5][x] === 0 &&\n                    array[y + 6][x] === 1 &&\n                    (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {\n                    numPenalties++;\n                }\n            }\n        }\n        return numPenalties * MaskUtil.N3;\n    };\n    MaskUtil.isWhiteHorizontal = function (rowArray, from /*int*/, to /*int*/) {\n        from = Math.max(from, 0);\n        to = Math.min(to, rowArray.length);\n        for (var i = from; i < to; i++) {\n            if (rowArray[i] === 1) {\n                return false;\n            }\n        }\n        return true;\n    };\n    MaskUtil.isWhiteVertical = function (array, col /*int*/, from /*int*/, to /*int*/) {\n        from = Math.max(from, 0);\n        to = Math.min(to, array.length);\n        for (var i = from; i < to; i++) {\n            if (array[i][col] === 1) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give\n     * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.\n     */\n    MaskUtil.applyMaskPenaltyRule4 = function (matrix) {\n        var numDarkCells = 0;\n        var array = matrix.getArray();\n        var width = matrix.getWidth();\n        var height = matrix.getHeight();\n        for (var y = 0; y < height; y++) {\n            var arrayY = array[y];\n            for (var x = 0; x < width; x++) {\n                if (arrayY[x] === 1) {\n                    numDarkCells++;\n                }\n            }\n        }\n        var numTotalCells = matrix.getHeight() * matrix.getWidth();\n        var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);\n        return fivePercentVariances * MaskUtil.N4;\n    };\n    /**\n     * Return the mask bit for \"getMaskPattern\" at \"x\" and \"y\". See 8.8 of JISX0510:2004 for mask\n     * pattern conditions.\n     */\n    MaskUtil.getDataMaskBit = function (maskPattern /*int*/, x /*int*/, y /*int*/) {\n        var intermediate; /*int*/\n        var temp; /*int*/\n        switch (maskPattern) {\n            case 0:\n                intermediate = (y + x) & 0x1;\n                break;\n            case 1:\n                intermediate = y & 0x1;\n                break;\n            case 2:\n                intermediate = x % 3;\n                break;\n            case 3:\n                intermediate = (y + x) % 3;\n                break;\n            case 4:\n                intermediate = (Math.floor(y / 2) + Math.floor(x / 3)) & 0x1;\n                break;\n            case 5:\n                temp = y * x;\n                intermediate = (temp & 0x1) + (temp % 3);\n                break;\n            case 6:\n                temp = y * x;\n                intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;\n                break;\n            case 7:\n                temp = y * x;\n                intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;\n                break;\n            default:\n                throw new IllegalArgumentException_1.default('Invalid mask pattern: ' + maskPattern);\n        }\n        return intermediate === 0;\n    };\n    /**\n     * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both\n     * vertical and horizontal orders respectively.\n     */\n    MaskUtil.applyMaskPenaltyRule1Internal = function (matrix, isHorizontal) {\n        var penalty = 0;\n        var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\n        var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\n        var array = matrix.getArray();\n        for (var i = 0; i < iLimit; i++) {\n            var numSameBitCells = 0;\n            var prevBit = -1;\n            for (var j = 0; j < jLimit; j++) {\n                var bit = isHorizontal ? array[i][j] : array[j][i];\n                if (bit === prevBit) {\n                    numSameBitCells++;\n                }\n                else {\n                    if (numSameBitCells >= 5) {\n                        penalty += MaskUtil.N1 + (numSameBitCells - 5);\n                    }\n                    numSameBitCells = 1; // Include the cell itself.\n                    prevBit = bit;\n                }\n            }\n            if (numSameBitCells >= 5) {\n                penalty += MaskUtil.N1 + (numSameBitCells - 5);\n            }\n        }\n        return penalty;\n    };\n    // Penalty weights from section 6.8.2.1\n    MaskUtil.N1 = 3;\n    MaskUtil.N2 = 3;\n    MaskUtil.N3 = 40;\n    MaskUtil.N4 = 10;\n    return MaskUtil;\n}());\nexports.default = MaskUtil;\n//# sourceMappingURL=MaskUtil.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","IllegalArgumentException_1","MaskUtil","applyMaskPenaltyRule1","MaskUtil.applyMaskPenaltyRule1","matrix","applyMaskPenaltyRule1Internal","applyMaskPenaltyRule2","MaskUtil.applyMaskPenaltyRule2","penalty","array","getArray","width","getWidth","height","getHeight","y","arrayY","x","N2","applyMaskPenaltyRule3","MaskUtil.applyMaskPenaltyRule3","numPenalties","isWhiteHorizontal","isWhiteVertical","N3","MaskUtil.isWhiteHorizontal","rowArray","from","to","Math","max","min","length","i","MaskUtil.isWhiteVertical","col","applyMaskPenaltyRule4","MaskUtil.applyMaskPenaltyRule4","numDarkCells","numTotalCells","floor","fivePercentVariances","abs","N4","getDataMaskBit","MaskUtil.getDataMaskBit","maskPattern","intermediate","temp","default","MaskUtil.applyMaskPenaltyRule1Internal","isHorizontal","iLimit","jLimit","numSameBitCells","prevBit","j","bit","N1"]
}
