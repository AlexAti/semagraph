{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$datamatrix$decoder$DecodedBitStreamParser.js",
"lineCount":18,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/datamatrix/decoder/DecodedBitStreamParser.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$datamatrix$decoder$DecodedBitStreamParser\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\nvar BitSource_1 = require(\"../../common/BitSource\");\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\nvar StringUtils_1 = require(\"../../common/StringUtils\");\nvar FormatException_1 = require(\"../../FormatException\");\nvar IllegalStateException_1 = require(\"../../IllegalStateException\");\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Mode;\n(function (Mode) {\n    Mode[Mode[\"PAD_ENCODE\"] = 0] = \"PAD_ENCODE\";\n    Mode[Mode[\"ASCII_ENCODE\"] = 1] = \"ASCII_ENCODE\";\n    Mode[Mode[\"C40_ENCODE\"] = 2] = \"C40_ENCODE\";\n    Mode[Mode[\"TEXT_ENCODE\"] = 3] = \"TEXT_ENCODE\";\n    Mode[Mode[\"ANSIX12_ENCODE\"] = 4] = \"ANSIX12_ENCODE\";\n    Mode[Mode[\"EDIFACT_ENCODE\"] = 5] = \"EDIFACT_ENCODE\";\n    Mode[Mode[\"BASE256_ENCODE\"] = 6] = \"BASE256_ENCODE\";\n})(Mode || (Mode = {}));\n/**\n * <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one Data Matrix Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>\n *\n * @author bbrown@google.com (Brian Brown)\n * @author Sean Owen\n */\nvar DecodedBitStreamParser = /** @class */ (function () {\n    function DecodedBitStreamParser() {\n    }\n    DecodedBitStreamParser.decode = function (bytes) {\n        var bits = new BitSource_1.default(bytes);\n        var result = new StringBuilder_1.default();\n        var resultTrailer = new StringBuilder_1.default();\n        var byteSegments = new Array();\n        var mode = Mode.ASCII_ENCODE;\n        do {\n            if (mode === Mode.ASCII_ENCODE) {\n                mode = this.decodeAsciiSegment(bits, result, resultTrailer);\n            }\n            else {\n                switch (mode) {\n                    case Mode.C40_ENCODE:\n                        this.decodeC40Segment(bits, result);\n                        break;\n                    case Mode.TEXT_ENCODE:\n                        this.decodeTextSegment(bits, result);\n                        break;\n                    case Mode.ANSIX12_ENCODE:\n                        this.decodeAnsiX12Segment(bits, result);\n                        break;\n                    case Mode.EDIFACT_ENCODE:\n                        this.decodeEdifactSegment(bits, result);\n                        break;\n                    case Mode.BASE256_ENCODE:\n                        this.decodeBase256Segment(bits, result, byteSegments);\n                        break;\n                    default:\n                        throw new FormatException_1.default();\n                }\n                mode = Mode.ASCII_ENCODE;\n            }\n        } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);\n        if (resultTrailer.length() > 0) {\n            result.append(resultTrailer.toString());\n        }\n        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);\n    };\n    /**\n     * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2\n     */\n    DecodedBitStreamParser.decodeAsciiSegment = function (bits, result, resultTrailer) {\n        var upperShift = false;\n        do {\n            var oneByte = bits.readBits(8);\n            if (oneByte === 0) {\n                throw new FormatException_1.default();\n            }\n            else if (oneByte <= 128) { // ASCII data (ASCII value + 1)\n                if (upperShift) {\n                    oneByte += 128;\n                    // upperShift = false;\n                }\n                result.append(String.fromCharCode(oneByte - 1));\n                return Mode.ASCII_ENCODE;\n            }\n            else if (oneByte === 129) { // Pad\n                return Mode.PAD_ENCODE;\n            }\n            else if (oneByte <= 229) { // 2-digit data 00-99 (Numeric Value + 130)\n                var value = oneByte - 130;\n                if (value < 10) { // pad with '0' for single digit values\n                    result.append('0');\n                }\n                result.append('' + value);\n            }\n            else {\n                switch (oneByte) {\n                    case 230: // Latch to C40 encodation\n                        return Mode.C40_ENCODE;\n                    case 231: // Latch to Base 256 encodation\n                        return Mode.BASE256_ENCODE;\n                    case 232: // FNC1\n                        result.append(String.fromCharCode(29)); // translate as ASCII 29\n                        break;\n                    case 233: // Structured Append\n                    case 234: // Reader Programming\n                        // Ignore these symbols for now\n                        // throw ReaderException.getInstance();\n                        break;\n                    case 235: // Upper Shift (shift to Extended ASCII)\n                        upperShift = true;\n                        break;\n                    case 236: // 05 Macro\n                        result.append('[)>\\u001E05\\u001D');\n                        resultTrailer.insert(0, '\\u001E\\u0004');\n                        break;\n                    case 237: // 06 Macro\n                        result.append('[)>\\u001E06\\u001D');\n                        resultTrailer.insert(0, '\\u001E\\u0004');\n                        break;\n                    case 238: // Latch to ANSI X12 encodation\n                        return Mode.ANSIX12_ENCODE;\n                    case 239: // Latch to Text encodation\n                        return Mode.TEXT_ENCODE;\n                    case 240: // Latch to EDIFACT encodation\n                        return Mode.EDIFACT_ENCODE;\n                    case 241: // ECI Character\n                        // TODO(bbrown): I think we need to support ECI\n                        // throw ReaderException.getInstance();\n                        // Ignore this symbol for now\n                        break;\n                    default:\n                        // Not to be used in ASCII encodation\n                        // but work around encoders that end with 254, latch back to ASCII\n                        if (oneByte !== 254 || bits.available() !== 0) {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                }\n            }\n        } while (bits.available() > 0);\n        return Mode.ASCII_ENCODE;\n    };\n    /**\n     * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1\n     */\n    DecodedBitStreamParser.decodeC40Segment = function (bits, result) {\n        // Three C40 values are encoded in a 16-bit value as\n        // (1600 * C1) + (40 * C2) + C3 + 1\n        // TODO(bbrown): The Upper Shift with C40 doesn't work in the 4 value scenario all the time\n        var upperShift = false;\n        var cValues = [];\n        var shift = 0;\n        do {\n            // If there is only one byte left then it will be encoded as ASCII\n            if (bits.available() === 8) {\n                return;\n            }\n            var firstByte = bits.readBits(8);\n            if (firstByte === 254) { // Unlatch codeword\n                return;\n            }\n            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n            for (var i = 0; i < 3; i++) {\n                var cValue = cValues[i];\n                switch (shift) {\n                    case 0:\n                        if (cValue < 3) {\n                            shift = cValue + 1;\n                        }\n                        else if (cValue < this.C40_BASIC_SET_CHARS.length) {\n                            var c40char = this.C40_BASIC_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(c40char);\n                            }\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case 1:\n                        if (upperShift) {\n                            result.append(String.fromCharCode(cValue + 128));\n                            upperShift = false;\n                        }\n                        else {\n                            result.append(String.fromCharCode(cValue));\n                        }\n                        shift = 0;\n                        break;\n                    case 2:\n                        if (cValue < this.C40_SHIFT2_SET_CHARS.length) {\n                            var c40char = this.C40_SHIFT2_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(c40char);\n                            }\n                        }\n                        else {\n                            switch (cValue) {\n                                case 27: // FNC1\n                                    result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                    break;\n                                case 30: // Upper Shift\n                                    upperShift = true;\n                                    break;\n                                default:\n                                    throw new FormatException_1.default();\n                            }\n                        }\n                        shift = 0;\n                        break;\n                    case 3:\n                        if (upperShift) {\n                            result.append(String.fromCharCode(cValue + 224));\n                            upperShift = false;\n                        }\n                        else {\n                            result.append(String.fromCharCode(cValue + 96));\n                        }\n                        shift = 0;\n                        break;\n                    default:\n                        throw new FormatException_1.default();\n                }\n            }\n        } while (bits.available() > 0);\n    };\n    /**\n     * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2\n     */\n    DecodedBitStreamParser.decodeTextSegment = function (bits, result) {\n        // Three Text values are encoded in a 16-bit value as\n        // (1600 * C1) + (40 * C2) + C3 + 1\n        // TODO(bbrown): The Upper Shift with Text doesn't work in the 4 value scenario all the time\n        var upperShift = false;\n        var cValues = [];\n        var shift = 0;\n        do {\n            // If there is only one byte left then it will be encoded as ASCII\n            if (bits.available() === 8) {\n                return;\n            }\n            var firstByte = bits.readBits(8);\n            if (firstByte === 254) { // Unlatch codeword\n                return;\n            }\n            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n            for (var i = 0; i < 3; i++) {\n                var cValue = cValues[i];\n                switch (shift) {\n                    case 0:\n                        if (cValue < 3) {\n                            shift = cValue + 1;\n                        }\n                        else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {\n                            var textChar = this.TEXT_BASIC_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(textChar);\n                            }\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case 1:\n                        if (upperShift) {\n                            result.append(String.fromCharCode(cValue + 128));\n                            upperShift = false;\n                        }\n                        else {\n                            result.append(String.fromCharCode(cValue));\n                        }\n                        shift = 0;\n                        break;\n                    case 2:\n                        // Shift 2 for Text is the same encoding as C40\n                        if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {\n                            var textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(textChar);\n                            }\n                        }\n                        else {\n                            switch (cValue) {\n                                case 27: // FNC1\n                                    result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                    break;\n                                case 30: // Upper Shift\n                                    upperShift = true;\n                                    break;\n                                default:\n                                    throw new FormatException_1.default();\n                            }\n                        }\n                        shift = 0;\n                        break;\n                    case 3:\n                        if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {\n                            var textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];\n                            if (upperShift) {\n                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(textChar);\n                            }\n                            shift = 0;\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    default:\n                        throw new FormatException_1.default();\n                }\n            }\n        } while (bits.available() > 0);\n    };\n    /**\n     * See ISO 16022:2006, 5.2.7\n     */\n    DecodedBitStreamParser.decodeAnsiX12Segment = function (bits, result) {\n        // Three ANSI X12 values are encoded in a 16-bit value as\n        // (1600 * C1) + (40 * C2) + C3 + 1\n        var cValues = [];\n        do {\n            // If there is only one byte left then it will be encoded as ASCII\n            if (bits.available() === 8) {\n                return;\n            }\n            var firstByte = bits.readBits(8);\n            if (firstByte === 254) { // Unlatch codeword\n                return;\n            }\n            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n            for (var i = 0; i < 3; i++) {\n                var cValue = cValues[i];\n                switch (cValue) {\n                    case 0: // X12 segment terminator <CR>\n                        result.append('\\r');\n                        break;\n                    case 1: // X12 segment separator *\n                        result.append('*');\n                        break;\n                    case 2: // X12 sub-element separator >\n                        result.append('>');\n                        break;\n                    case 3: // space\n                        result.append(' ');\n                        break;\n                    default:\n                        if (cValue < 14) { // 0 - 9\n                            result.append(String.fromCharCode(cValue + 44));\n                        }\n                        else if (cValue < 40) { // A - Z\n                            result.append(String.fromCharCode(cValue + 51));\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                }\n            }\n        } while (bits.available() > 0);\n    };\n    DecodedBitStreamParser.parseTwoBytes = function (firstByte, secondByte, result) {\n        var fullBitValue = (firstByte << 8) + secondByte - 1;\n        var temp = Math.floor(fullBitValue / 1600);\n        result[0] = temp;\n        fullBitValue -= temp * 1600;\n        temp = Math.floor(fullBitValue / 40);\n        result[1] = temp;\n        result[2] = fullBitValue - temp * 40;\n    };\n    /**\n     * See ISO 16022:2006, 5.2.8 and Annex C Table C.3\n     */\n    DecodedBitStreamParser.decodeEdifactSegment = function (bits, result) {\n        do {\n            // If there is only two or less bytes left then it will be encoded as ASCII\n            if (bits.available() <= 16) {\n                return;\n            }\n            for (var i = 0; i < 4; i++) {\n                var edifactValue = bits.readBits(6);\n                // Check for the unlatch character\n                if (edifactValue === 0x1F) { // 011111\n                    // Read rest of byte, which should be 0, and stop\n                    var bitsLeft = 8 - bits.getBitOffset();\n                    if (bitsLeft !== 8) {\n                        bits.readBits(bitsLeft);\n                    }\n                    return;\n                }\n                if ((edifactValue & 0x20) === 0) { // no 1 in the leading (6th) bit\n                    edifactValue |= 0x40; // Add a leading 01 to the 6 bit binary value\n                }\n                result.append(String.fromCharCode(edifactValue));\n            }\n        } while (bits.available() > 0);\n    };\n    /**\n     * See ISO 16022:2006, 5.2.9 and Annex B, B.2\n     */\n    DecodedBitStreamParser.decodeBase256Segment = function (bits, result, byteSegments) {\n        // Figure out how long the Base 256 Segment is.\n        var codewordPosition = 1 + bits.getByteOffset(); // position is 1-indexed\n        var d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n        var count;\n        if (d1 === 0) { // Read the remainder of the symbol\n            count = bits.available() / 8 | 0;\n        }\n        else if (d1 < 250) {\n            count = d1;\n        }\n        else {\n            count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);\n        }\n        // We're seeing NegativeArraySizeException errors from users.\n        if (count < 0) {\n            throw new FormatException_1.default();\n        }\n        var bytes = new Uint8Array(count);\n        for (var i = 0; i < count; i++) {\n            // Have seen this particular error in the wild, such as at\n            // http://www.bcgen.com/demo/IDAutomationStreamingDataMatrix.aspx?MODE=3&D=Fred&PFMT=3&PT=F&X=0.3&O=0&LM=0.2\n            if (bits.available() < 8) {\n                throw new FormatException_1.default();\n            }\n            bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n        }\n        byteSegments.push(bytes);\n        try {\n            result.append(StringEncoding_1.default.decode(bytes, StringUtils_1.default.ISO88591));\n        }\n        catch (uee) {\n            throw new IllegalStateException_1.default('Platform does not support required encoding: ' + uee.message);\n        }\n    };\n    /**\n     * See ISO 16022:2006, Annex B, B.2\n     */\n    DecodedBitStreamParser.unrandomize255State = function (randomizedBase256Codeword, base256CodewordPosition) {\n        var pseudoRandomNumber = ((149 * base256CodewordPosition) % 255) + 1;\n        var tempVariable = randomizedBase256Codeword - pseudoRandomNumber;\n        return tempVariable >= 0 ? tempVariable : tempVariable + 256;\n    };\n    /**\n     * See ISO 16022:2006, Annex C Table C.1\n     * The C40 Basic Character Set (*'s used for placeholders for the shift values)\n     */\n    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [\n        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n    ];\n    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [\n        '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.',\n        '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\\\', ']', '^', '_'\n    ];\n    /**\n     * See ISO 16022:2006, Annex C Table C.2\n     * The Text Basic Character Set (*'s used for placeholders for the shift values)\n     */\n    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [\n        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    ];\n    // Shift 2 for Text is the same encoding as C40\n    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;\n    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [\n        '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', String.fromCharCode(127)\n    ];\n    return DecodedBitStreamParser;\n}());\nexports.default = DecodedBitStreamParser;\n//# sourceMappingURL=DecodedBitStreamParser.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","DecoderResult_1","BitSource_1","StringBuilder_1","StringEncoding_1","StringUtils_1","FormatException_1","IllegalStateException_1","Mode","DecodedBitStreamParser","decode","DecodedBitStreamParser.decode","bytes","bits","default","result","resultTrailer","byteSegments","mode","ASCII_ENCODE","decodeAsciiSegment","C40_ENCODE","decodeC40Segment","TEXT_ENCODE","decodeTextSegment","ANSIX12_ENCODE","decodeAnsiX12Segment","EDIFACT_ENCODE","decodeEdifactSegment","BASE256_ENCODE","decodeBase256Segment","PAD_ENCODE","available","length","append","toString","DecodedBitStreamParser.decodeAsciiSegment","upperShift","oneByte","readBits","String","fromCharCode","insert","DecodedBitStreamParser.decodeC40Segment","cValues","shift","firstByte","parseTwoBytes","i","cValue","C40_BASIC_SET_CHARS","c40char","charCodeAt","C40_SHIFT2_SET_CHARS","DecodedBitStreamParser.decodeTextSegment","TEXT_BASIC_SET_CHARS","textChar","TEXT_SHIFT2_SET_CHARS","TEXT_SHIFT3_SET_CHARS","DecodedBitStreamParser.decodeAnsiX12Segment","DecodedBitStreamParser.parseTwoBytes","secondByte","fullBitValue","temp","Math","floor","DecodedBitStreamParser.decodeEdifactSegment","edifactValue","bitsLeft","getBitOffset","DecodedBitStreamParser.decodeBase256Segment","codewordPosition","getByteOffset","d1","unrandomize255State","count","Uint8Array","push","ISO88591","uee","message","DecodedBitStreamParser.unrandomize255State","randomizedBase256Codeword","base256CodewordPosition","tempVariable"]
}
