{
"version":3,
"file":"module$node_modules$qrcode$lib$core$bit_matrix.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,8CAAA,CAAmE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAM3GC,QAASA,UAAU,CAACC,IAAD,CAAO,CACxB,GAAI,CAACA,IAAL,EAAoB,CAApB,CAAaA,IAAb,CACE,KAAUC,MAAJ,CAAU,mDAAV,CAAN,CAGF,IAAKD,CAAAA,IAAL,CAAYA,IACZ,KAAKE,CAAAA,IAAL,CAAY,IAAIC,UAAJ,CAAeH,IAAf,CAAsBA,IAAtB,CACZ,KAAKI,CAAAA,WAAL,CAAmB,IAAID,UAAJ,CAAeH,IAAf,CAAsBA,IAAtB,CAPK,CAmB1BD,SAAUM,CAAAA,SAAUC,CAAAA,GAApB,CAA0BC,QAAS,CAACC,GAAD,CAAMC,GAAN,CAAWC,KAAX,CAAkBC,QAAlB,CAA4B,CACvDC,GAAAA,CAAQJ,GAARI,CAAc,IAAKZ,CAAAA,IAAnBY,CAA0BH,GAChC,KAAKP,CAAAA,IAAL,CAAUU,GAAV,CAAA,CAAmBF,KACfC,SAAJ,GAAc,IAAKP,CAAAA,WAAL,CAAiBQ,GAAjB,CAAd,CAAwC,CAAA,CAAxC,CAH6D,CAa/Db,UAAUM,CAAAA,SAAUQ,CAAAA,GAApB,CAA0BC,QAAS,CAACN,GAAD,CAAMC,GAAN,CAAW,CAC5C,MAAO,KAAKP,CAAAA,IAAL,CAAUM,GAAV;AAAgB,IAAKR,CAAAA,IAArB,CAA4BS,GAA5B,CADqC,CAY9CV,UAAUM,CAAAA,SAAUU,CAAAA,GAApB,CAA0BC,QAAS,CAACR,GAAD,CAAMC,GAAN,CAAWC,KAAX,CAAkB,CACnD,IAAKR,CAAAA,IAAL,CAAUM,GAAV,CAAgB,IAAKR,CAAAA,IAArB,CAA4BS,GAA5B,CAAA,EAAoCC,KADe,CAWrDX,UAAUM,CAAAA,SAAUY,CAAAA,UAApB,CAAiCC,QAAS,CAACV,GAAD,CAAMC,GAAN,CAAW,CACnD,MAAO,KAAKL,CAAAA,WAAL,CAAiBI,GAAjB,CAAuB,IAAKR,CAAAA,IAA5B,CAAmCS,GAAnC,CAD4C,CAIrDZ,OAAOC,CAAAA,OAAP,CAAiBC,SAjE0F;",
"sources":["node_modules/qrcode/lib/core/bit-matrix.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$qrcode$lib$core$bit_matrix\"] = function(global,require,module,exports) {\n/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix (size) {\n  if (!size || size < 1) {\n    throw new Error('BitMatrix size must be defined and greater than 0')\n  }\n\n  this.size = size\n  this.data = new Uint8Array(size * size)\n  this.reservedBit = new Uint8Array(size * size)\n}\n\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n  const index = row * this.size + col\n  this.data[index] = value\n  if (reserved) this.reservedBit[index] = true\n}\n\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n  return this.data[row * this.size + col]\n}\n\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n  this.data[row * this.size + col] ^= value\n}\n\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n  return this.reservedBit[row * this.size + col]\n}\n\nmodule.exports = BitMatrix\n\n};"],
"names":["shadow$provide","global","require","module","exports","BitMatrix","size","Error","data","Uint8Array","reservedBit","prototype","set","BitMatrix.prototype.set","row","col","value","reserved","index","get","BitMatrix.prototype.get","xor","BitMatrix.prototype.xor","isReserved","BitMatrix.prototype.isReserved"]
}
