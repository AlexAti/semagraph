{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$DecodedBitStreamParser.js",
"lineCount":14,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/decoder/DecodedBitStreamParser.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$DecodedBitStreamParser\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode.decoder {*/\nvar BitSource_1 = require(\"../../common/BitSource\");\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\nvar StringUtils_1 = require(\"../../common/StringUtils\");\nvar FormatException_1 = require(\"../../FormatException\");\nvar StringBuilder_1 = require(\"../../util/StringBuilder\");\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\nvar Mode_1 = require(\"./Mode\");\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n * in one QR Code. This class decodes the bits back into text.</p>\n *\n * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n *\n * @author Sean Owen\n */\nvar DecodedBitStreamParser = /** @class */ (function () {\n    function DecodedBitStreamParser() {\n    }\n    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {\n        var bits = new BitSource_1.default(bytes);\n        var result = new StringBuilder_1.default();\n        var byteSegments = new Array(); // 1\n        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n        var symbolSequence = -1;\n        var parityData = -1;\n        try {\n            var currentCharacterSetECI = null;\n            var fc1InEffect = false;\n            var mode = void 0;\n            do {\n                // While still another segment to read...\n                if (bits.available() < 4) {\n                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n                    mode = Mode_1.default.TERMINATOR;\n                }\n                else {\n                    var modeBits = bits.readBits(4);\n                    mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits\n                }\n                switch (mode) {\n                    case Mode_1.default.TERMINATOR:\n                        break;\n                    case Mode_1.default.FNC1_FIRST_POSITION:\n                    case Mode_1.default.FNC1_SECOND_POSITION:\n                        // We do little with FNC1 except alter the parsed result a bit according to the spec\n                        fc1InEffect = true;\n                        break;\n                    case Mode_1.default.STRUCTURED_APPEND:\n                        if (bits.available() < 16) {\n                            throw new FormatException_1.default();\n                        }\n                        // sequence number and parity is added later to the result metadata\n                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n                        symbolSequence = bits.readBits(8);\n                        parityData = bits.readBits(8);\n                        break;\n                    case Mode_1.default.ECI:\n                        // Count doesn't apply to ECI\n                        var value = DecodedBitStreamParser.parseECIValue(bits);\n                        currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);\n                        if (currentCharacterSetECI === null) {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case Mode_1.default.HANZI:\n                        // First handle Hanzi mode which does not start with character count\n                        // Chinese mode contains a sub set indicator right after mode indicator\n                        var subset = bits.readBits(4);\n                        var countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {\n                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);\n                        }\n                        break;\n                    default:\n                        // \"Normal\" QR code modes:\n                        // How many characters will follow, encoded in this mode?\n                        var count = bits.readBits(mode.getCharacterCountBits(version));\n                        switch (mode) {\n                            case Mode_1.default.NUMERIC:\n                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);\n                                break;\n                            case Mode_1.default.ALPHANUMERIC:\n                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                                break;\n                            case Mode_1.default.BYTE:\n                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                                break;\n                            case Mode_1.default.KANJI:\n                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);\n                                break;\n                            default:\n                                throw new FormatException_1.default();\n                        }\n                        break;\n                }\n            } while (mode !== Mode_1.default.TERMINATOR);\n        }\n        catch (iae /*: IllegalArgumentException*/) {\n            // from readBits() calls\n            throw new FormatException_1.default();\n        }\n        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n    };\n    /**\n     * See specification GBT 18284-2000\n     */\n    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as GB2312 afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);\n            if (assembledTwoBytes < 0x003BF) {\n                // In the 0xA1A1 to 0xAAFE range\n                assembledTwoBytes += 0x0A1A1;\n            }\n            else {\n                // In the 0xB0A1 to 0xFAFE range\n                assembledTwoBytes += 0x0A6A1;\n            }\n            buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);\n            buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);\n            offset += 2;\n            count--;\n        }\n        try {\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312));\n            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {\n        // Don't crash trying to read more bits than we have available.\n        if (count * 13 > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        // Each character will require 2 bytes. Read the characters as 2-byte pairs\n        // and decode as Shift_JIS afterwards\n        var buffer = new Uint8Array(2 * count);\n        var offset = 0;\n        while (count > 0) {\n            // Each 13 bits encodes a 2-byte character\n            var twoBytes = bits.readBits(13);\n            var assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);\n            if (assembledTwoBytes < 0x01F00) {\n                // In the 0x8140 to 0x9FFC range\n                assembledTwoBytes += 0x08140;\n            }\n            else {\n                // In the 0xE040 to 0xEBBF range\n                assembledTwoBytes += 0x0C140;\n            }\n            buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);\n            buffer[offset + 1] = /*(byte) */ assembledTwoBytes;\n            offset += 2;\n            count--;\n        }\n        // Shift_JIS may not be supported in some environments:\n        try {\n            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS));\n            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n    };\n    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {\n        // Don't crash trying to read more bits than we have available.\n        if (8 * count > bits.available()) {\n            throw new FormatException_1.default();\n        }\n        var readBytes = new Uint8Array(count);\n        for (var i = 0; i < count; i++) {\n            readBytes[i] = /*(byte) */ bits.readBits(8);\n        }\n        var encoding;\n        if (currentCharacterSetECI === null) {\n            // The spec isn't clear on this mode; see\n            // section 6.4.5: t does not say which encoding to assuming\n            // upon decoding. I have seen ISO-8859-1 used as well as\n            // Shift_JIS -- without anything like an ECI designator to\n            // give a hint.\n            encoding = StringUtils_1.default.guessEncoding(readBytes, hints);\n        }\n        else {\n            encoding = currentCharacterSetECI.getName();\n        }\n        try {\n            result.append(StringEncoding_1.default.decode(readBytes, encoding));\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            throw new FormatException_1.default(ignored);\n        }\n        byteSegments.push(readBytes);\n    };\n    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {\n        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {\n            throw new FormatException_1.default();\n        }\n        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];\n    };\n    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {\n        // Read two characters at a time\n        var start = result.length();\n        while (count > 1) {\n            if (bits.available() < 11) {\n                throw new FormatException_1.default();\n            }\n            var nextTwoCharsBits = bits.readBits(11);\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));\n            count -= 2;\n        }\n        if (count === 1) {\n            // special case: one character left\n            if (bits.available() < 6) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));\n        }\n        // See section 6.4.8.1, 6.4.8.2\n        if (fc1InEffect) {\n            // We need to massage the result a bit if in an FNC1 mode:\n            for (var i = start; i < result.length(); i++) {\n                if (result.charAt(i) === '%') {\n                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n                        // %% is rendered as %\n                        result.deleteCharAt(i + 1);\n                    }\n                    else {\n                        // In alpha mode, % should be converted to FNC1 separator 0x1D\n                        result.setCharAt(i, String.fromCharCode(0x1D));\n                    }\n                }\n            }\n        }\n    };\n    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {\n        // Read three digits at a time\n        while (count >= 3) {\n            // Each 10 bits encodes three digits\n            if (bits.available() < 10) {\n                throw new FormatException_1.default();\n            }\n            var threeDigitsBits = bits.readBits(10);\n            if (threeDigitsBits >= 1000) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));\n            count -= 3;\n        }\n        if (count === 2) {\n            // Two digits left over to read, encoded in 7 bits\n            if (bits.available() < 7) {\n                throw new FormatException_1.default();\n            }\n            var twoDigitsBits = bits.readBits(7);\n            if (twoDigitsBits >= 100) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));\n        }\n        else if (count === 1) {\n            // One digit left over to read\n            if (bits.available() < 4) {\n                throw new FormatException_1.default();\n            }\n            var digitBits = bits.readBits(4);\n            if (digitBits >= 10) {\n                throw new FormatException_1.default();\n            }\n            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));\n        }\n    };\n    DecodedBitStreamParser.parseECIValue = function (bits) {\n        var firstByte = bits.readBits(8);\n        if ((firstByte & 0x80) === 0) {\n            // just one byte\n            return firstByte & 0x7F;\n        }\n        if ((firstByte & 0xC0) === 0x80) {\n            // two bytes\n            var secondByte = bits.readBits(8);\n            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;\n        }\n        if ((firstByte & 0xE0) === 0xC0) {\n            // three bytes\n            var secondThirdBytes = bits.readBits(16);\n            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;\n        }\n        throw new FormatException_1.default();\n    };\n    /**\n     * See ISO 18004:2006, 6.4.4 Table 5\n     */\n    DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n    DecodedBitStreamParser.GB2312_SUBSET = 1;\n    return DecodedBitStreamParser;\n}());\nexports.default = DecodedBitStreamParser;\n// function Uint8ArrayToString(a: Uint8Array): string {\n//     const CHUNK_SZ = 0x8000;\n//     const c = new StringBuilder();\n//     for (let i = 0, length = a.length; i < length; i += CHUNK_SZ) {\n//         c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n//     }\n//     return c.toString();\n// }\n//# sourceMappingURL=DecodedBitStreamParser.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","BitSource_1","CharacterSetECI_1","DecoderResult_1","StringUtils_1","FormatException_1","StringBuilder_1","StringEncoding_1","Mode_1","DecodedBitStreamParser","decode","DecodedBitStreamParser.decode","bytes","version","ecLevel","hints","bits","default","result","byteSegments","symbolSequence","parityData","currentCharacterSetECI","fc1InEffect","mode","available","TERMINATOR","modeBits","readBits","forBits","FNC1_FIRST_POSITION","FNC1_SECOND_POSITION","STRUCTURED_APPEND","ECI","parseECIValue","getCharacterSetECIByValue","HANZI","subset","countHanzi","getCharacterCountBits","GB2312_SUBSET","decodeHanziSegment","count","NUMERIC","decodeNumericSegment","ALPHANUMERIC","decodeAlphanumericSegment","BYTE","decodeByteSegment","KANJI","decodeKanjiSegment","iae","toString","length","DecodedBitStreamParser.decodeHanziSegment","buffer","Uint8Array","offset","twoBytes","assembledTwoBytes","append","GB2312","ignored","DecodedBitStreamParser.decodeKanjiSegment","SHIFT_JIS","DecodedBitStreamParser.decodeByteSegment","readBytes","i","encoding","guessEncoding","getName","push","toAlphaNumericChar","DecodedBitStreamParser.toAlphaNumericChar","ALPHANUMERIC_CHARS","DecodedBitStreamParser.decodeAlphanumericSegment","start","nextTwoCharsBits","Math","floor","charAt","deleteCharAt","setCharAt","String","fromCharCode","DecodedBitStreamParser.decodeNumericSegment","threeDigitsBits","twoDigitsBits","digitBits","DecodedBitStreamParser.parseECIValue","firstByte","secondByte","secondThirdBytes"]
}
