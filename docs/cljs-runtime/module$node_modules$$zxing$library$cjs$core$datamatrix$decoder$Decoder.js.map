{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$datamatrix$decoder$Decoder.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/datamatrix/decoder/Decoder.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$datamatrix$decoder$Decoder\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChecksumException_1 = require(\"../../ChecksumException\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\nvar BitMatrixParser_1 = require(\"./BitMatrixParser\");\nvar DataBlock_1 = require(\"./DataBlock\");\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting\n * the Data Matrix Code from an image.</p>\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar Decoder = /** @class */ (function () {\n    function Decoder() {\n        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.DATA_MATRIX_FIELD_256);\n    }\n    /**\n     * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken\n     * to mean a black module.</p>\n     *\n     * @param bits booleans representing white/black Data Matrix Code modules\n     * @return text and bytes encoded within the Data Matrix Code\n     * @throws FormatException if the Data Matrix Code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.decode = function (bits) {\n        var e_1, _a;\n        // Construct a parser and read version, error-correction level\n        var parser = new BitMatrixParser_1.default(bits);\n        var version = parser.getVersion();\n        // Read codewords\n        var codewords = parser.readCodewords();\n        // Separate into data blocks\n        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version);\n        // Count total number of data bytes\n        var totalBytes = 0;\n        try {\n            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\n                var db = dataBlocks_1_1.value;\n                totalBytes += db.getNumDataCodewords();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var resultBytes = new Uint8Array(totalBytes);\n        var dataBlocksCount = dataBlocks.length;\n        // Error-correct and copy data blocks together into a stream of bytes\n        for (var j = 0; j < dataBlocksCount; j++) {\n            var dataBlock = dataBlocks[j];\n            var codewordBytes = dataBlock.getCodewords();\n            var numDataCodewords = dataBlock.getNumDataCodewords();\n            this.correctErrors(codewordBytes, numDataCodewords);\n            for (var i = 0; i < numDataCodewords; i++) {\n                // De-interlace data blocks.\n                resultBytes[i * dataBlocksCount + j] = codewordBytes[i];\n            }\n        }\n        // Decode the contents of that stream of bytes\n        return DecodedBitStreamParser_1.default.decode(resultBytes);\n    };\n    /**\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n     * correct the errors in-place using Reed-Solomon error correction.</p>\n     *\n     * @param codewordBytes data and error correction codewords\n     * @param numDataCodewords number of codewords that are data bytes\n     * @throws ChecksumException if error correction fails\n     */\n    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords) {\n        // const numCodewords = codewordBytes.length;\n        // First read into an array of ints\n        var codewordsInts = new Int32Array(codewordBytes);\n        // for (let i = 0; i < numCodewords; i++) {\n        //   codewordsInts[i] = codewordBytes[i] & 0xFF;\n        // }\n        try {\n            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n        }\n        catch (ignored /* ReedSolomonException */) {\n            throw new ChecksumException_1.default();\n        }\n        // Copy back into array of bytes -- only need to worry about the bytes that were data\n        // We don't care about errors in the error-correction codewords\n        for (var i = 0; i < numDataCodewords; i++) {\n            codewordBytes[i] = codewordsInts[i];\n        }\n    };\n    return Decoder;\n}());\nexports.default = Decoder;\n//# sourceMappingURL=Decoder.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","Object","defineProperty","ChecksumException_1","GenericGF_1","ReedSolomonDecoder_1","BitMatrixParser_1","DataBlock_1","DecodedBitStreamParser_1","Decoder","rsDecoder","default","DATA_MATRIX_FIELD_256","prototype","decode","Decoder.prototype.decode","bits","_a","parser","version","getVersion","codewords","readCodewords","dataBlocks","getDataBlocks","totalBytes","dataBlocks_1","dataBlocks_1_1","getNumDataCodewords","e_1_1","e_1","error","return","resultBytes","Uint8Array","dataBlocksCount","j","dataBlock","codewordBytes","getCodewords","numDataCodewords","correctErrors","Decoder.prototype.correctErrors","codewordsInts","Int32Array","ignored"]
}
