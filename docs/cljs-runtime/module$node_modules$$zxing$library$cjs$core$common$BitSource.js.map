{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$common$BitSource.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,4DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAiBzHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAEA,KAAIC,2BAA6BN,OAAA,CAAQ,sEAAR,CAU7BO,OAAAA,CAA2B,QAAS,EAAG,CAKvCA,QAASA,UAAS,CAACC,KAAD,CAAQ,CACtB,IAAKA,CAAAA,KAAL,CAAaA,KAEb,KAAKC,CAAAA,SAAL,CADA,IAAKC,CAAAA,UACL,CADkB,CAFI,CAQ1BH,SAAUI,CAAAA,SAAUC,CAAAA,YAApB,CAAmCC,QAAS,EAAG,CAC3C,MAAO,KAAKJ,CAAAA,SAD+B,CAM/CF,UAAUI,CAAAA,SAAUG,CAAAA,aAApB,CAAoCC,QAAS,EAAG,CAC5C,MAAO,KAAKL,CAAAA,UADgC,CAShDH;SAAUI,CAAAA,SAAUK,CAAAA,QAApB,CAA+BC,QAAS,CAACC,OAAD,CAAkB,CACtD,GAAc,CAAd,CAAIA,OAAJ,EAA6B,EAA7B,CAAmBA,OAAnB,EAAmCA,OAAnC,CAA6C,IAAKC,CAAAA,SAAL,EAA7C,CACI,KAAM,KAAIb,0BAA2Bc,CAAAA,OAA/B,CAAuC,EAAvC,CAA4CF,OAA5C,CAAN,CAEJ,IAAIG,OAAS,CAAb,CACIZ,UAAY,IAAKA,CAAAA,SADrB,CAEIC,WAAa,IAAKA,CAAAA,UAFtB,CAGIF,MAAQ,IAAKA,CAAAA,KAEjB,IAAgB,CAAhB,CAAIC,SAAJ,CAAmB,CACXa,MAAAA,CAAW,CAAXA,CAAeb,SACnB,KAAIc,OAASL,OAAA,CAAUI,MAAV,CAAqBJ,OAArB,CAA+BI,MAA5C,CACIE,cAAgBF,MAAhBE,CAA2BD,MAE/BF,OAAA,EAAUb,KAAA,CAAME,UAAN,CAAV,CADY,GACZ,EADqB,CACrB,CADyBa,MACzB,EADqCC,aACrC,GAAuCA,aACvCN,QAAA,EAAWK,MACXd,UAAA,EAAac,MACK,EAAlB,GAAId,SAAJ,GACIA,SACA,CADY,CACZ,CAAAC,UAAA,EAFJ,CARe,CAcnB,GAAc,CAAd,CAAIQ,OAAJ,CAAiB,CACb,IAAA,CAAkB,CAAlB;AAAOA,OAAP,CAAA,CACIG,MAEA,CAFUA,MAEV,EAFoB,CAEpB,CAF0Bb,KAAA,CAAME,UAAN,CAE1B,CAF8C,GAE9C,CADAA,UAAA,EACA,CAAAQ,OAAA,EAAW,CAGD,EAAd,CAAIA,OAAJ,GACQM,aAGJ,CAHoB,CAGpB,CAHwBN,OAGxB,CADAG,MACA,CADUA,MACV,EADoBH,OACpB,EADiCV,KAAA,CAAME,UAAN,CACjC,CAFY,GAEZ,EAFoBc,aAEpB,EAFsCA,aAEtC,GAD8DA,aAC9D,CAAAf,SAAA,EAAaS,OAJjB,CAPa,CAcjB,IAAKT,CAAAA,SAAL,CAAiBA,SACjB,KAAKC,CAAAA,UAAL,CAAkBA,UAClB,OAAOW,OAvC+C,CA4C1Dd,UAAUI,CAAAA,SAAUQ,CAAAA,SAApB,CAAgCM,QAAS,EAAG,CACxC,MAAO,EAAP,EAAY,IAAKjB,CAAAA,KAAMkB,CAAAA,MAAvB,CAAgC,IAAKhB,CAAAA,UAArC,EAAmD,IAAKD,CAAAA,SADhB,CAG5C,OAAOF,UA3EgC,CAAZ,EA6E/BL,QAAQkB,CAAAA,OAAR,CAAkBb,MA1GuG;",
"sources":["node_modules/@zxing/library/cjs/core/common/BitSource.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$common$BitSource\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common {*/\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n/**\n * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\n * number of bits read is not often a multiple of 8.</p>\n *\n * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\n * it passed in, in which case all bets are off.</p>\n *\n * @author Sean Owen\n */\nvar BitSource = /** @class */ (function () {\n    /**\n     * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\n     * Bits are read within a byte from most-significant to least-significant bit.\n     */\n    function BitSource(bytes) {\n        this.bytes = bytes;\n        this.byteOffset = 0;\n        this.bitOffset = 0;\n    }\n    /**\n     * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\n     */\n    BitSource.prototype.getBitOffset = function () {\n        return this.bitOffset;\n    };\n    /**\n     * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\n     */\n    BitSource.prototype.getByteOffset = function () {\n        return this.byteOffset;\n    };\n    /**\n     * @param numBits number of bits to read\n     * @return int representing the bits read. The bits will appear as the least-significant\n     *         bits of the int\n     * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\n     */\n    BitSource.prototype.readBits = function (numBits /*int*/) {\n        if (numBits < 1 || numBits > 32 || numBits > this.available()) {\n            throw new IllegalArgumentException_1.default('' + numBits);\n        }\n        var result = 0;\n        var bitOffset = this.bitOffset;\n        var byteOffset = this.byteOffset;\n        var bytes = this.bytes;\n        // First, read remainder from current byte\n        if (bitOffset > 0) {\n            var bitsLeft = 8 - bitOffset;\n            var toRead = numBits < bitsLeft ? numBits : bitsLeft;\n            var bitsToNotRead = bitsLeft - toRead;\n            var mask = (0xFF >> (8 - toRead)) << bitsToNotRead;\n            result = (bytes[byteOffset] & mask) >> bitsToNotRead;\n            numBits -= toRead;\n            bitOffset += toRead;\n            if (bitOffset === 8) {\n                bitOffset = 0;\n                byteOffset++;\n            }\n        }\n        // Next read whole bytes\n        if (numBits > 0) {\n            while (numBits >= 8) {\n                result = (result << 8) | (bytes[byteOffset] & 0xFF);\n                byteOffset++;\n                numBits -= 8;\n            }\n            // Finally read a partial byte\n            if (numBits > 0) {\n                var bitsToNotRead = 8 - numBits;\n                var mask = (0xFF >> bitsToNotRead) << bitsToNotRead;\n                result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);\n                bitOffset += numBits;\n            }\n        }\n        this.bitOffset = bitOffset;\n        this.byteOffset = byteOffset;\n        return result;\n    };\n    /**\n     * @return number of bits that can be read successfully\n     */\n    BitSource.prototype.available = function () {\n        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\n    };\n    return BitSource;\n}());\nexports.default = BitSource;\n//# sourceMappingURL=BitSource.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","IllegalArgumentException_1","BitSource","bytes","bitOffset","byteOffset","prototype","getBitOffset","BitSource.prototype.getBitOffset","getByteOffset","BitSource.prototype.getByteOffset","readBits","BitSource.prototype.readBits","numBits","available","default","result","bitsLeft","toRead","bitsToNotRead","BitSource.prototype.available","length"]
}
