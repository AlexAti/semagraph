{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$common$BitArray.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/common/BitArray.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$common$BitArray\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common {*/\n/*import java.util.Arrays;*/\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\nvar Arrays_1 = require(\"../util/Arrays\");\nvar Integer_1 = require(\"../util/Integer\");\nvar System_1 = require(\"../util/System\");\n/**\n * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>\n *\n * @author Sean Owen\n */\nvar BitArray /*implements Cloneable*/ = /** @class */ (function () {\n    // public constructor() {\n    //   this.size = 0\n    //   this.bits = new Int32Array(1)\n    // }\n    // public constructor(size?: number /*int*/) {\n    //   if (undefined === size) {\n    //     this.size = 0\n    //   } else {\n    //     this.size = size\n    //   }\n    //   this.bits = this.makeArray(size)\n    // }\n    // For testing only\n    function BitArray(size /*int*/, bits) {\n        if (undefined === size) {\n            this.size = 0;\n            this.bits = new Int32Array(1);\n        }\n        else {\n            this.size = size;\n            if (undefined === bits || null === bits) {\n                this.bits = BitArray.makeArray(size);\n            }\n            else {\n                this.bits = bits;\n            }\n        }\n    }\n    BitArray.prototype.getSize = function () {\n        return this.size;\n    };\n    BitArray.prototype.getSizeInBytes = function () {\n        return Math.floor((this.size + 7) / 8);\n    };\n    BitArray.prototype.ensureCapacity = function (size /*int*/) {\n        if (size > this.bits.length * 32) {\n            var newBits = BitArray.makeArray(size);\n            System_1.default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);\n            this.bits = newBits;\n        }\n    };\n    /**\n     * @param i bit to get\n     * @return true iff bit i is set\n     */\n    BitArray.prototype.get = function (i /*int*/) {\n        return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;\n    };\n    /**\n     * Sets bit i.\n     *\n     * @param i bit to set\n     */\n    BitArray.prototype.set = function (i /*int*/) {\n        this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);\n    };\n    /**\n     * Flips bit i.\n     *\n     * @param i bit to set\n     */\n    BitArray.prototype.flip = function (i /*int*/) {\n        this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);\n    };\n    /**\n     * @param from first bit to check\n     * @return index of first bit that is set, starting from the given index, or size if none are set\n     *  at or beyond this given index\n     * @see #getNextUnset(int)\n     */\n    BitArray.prototype.getNextSet = function (from /*int*/) {\n        var size = this.size;\n        if (from >= size) {\n            return size;\n        }\n        var bits = this.bits;\n        var bitsOffset = Math.floor(from / 32);\n        var currentBits = bits[bitsOffset];\n        // mask off lesser bits first\n        currentBits &= ~((1 << (from & 0x1F)) - 1);\n        var length = bits.length;\n        while (currentBits === 0) {\n            if (++bitsOffset === length) {\n                return size;\n            }\n            currentBits = bits[bitsOffset];\n        }\n        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);\n        return result > size ? size : result;\n    };\n    /**\n     * @param from index to start looking for unset bit\n     * @return index of next unset bit, or {@code size} if none are unset until the end\n     * @see #getNextSet(int)\n     */\n    BitArray.prototype.getNextUnset = function (from /*int*/) {\n        var size = this.size;\n        if (from >= size) {\n            return size;\n        }\n        var bits = this.bits;\n        var bitsOffset = Math.floor(from / 32);\n        var currentBits = ~bits[bitsOffset];\n        // mask off lesser bits first\n        currentBits &= ~((1 << (from & 0x1F)) - 1);\n        var length = bits.length;\n        while (currentBits === 0) {\n            if (++bitsOffset === length) {\n                return size;\n            }\n            currentBits = ~bits[bitsOffset];\n        }\n        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);\n        return result > size ? size : result;\n    };\n    /**\n     * Sets a block of 32 bits, starting at bit i.\n     *\n     * @param i first bit to set\n     * @param newBits the new value of the next 32 bits. Note again that the least-significant bit\n     * corresponds to bit i, the next-least-significant to i+1, and so on.\n     */\n    BitArray.prototype.setBulk = function (i /*int*/, newBits /*int*/) {\n        this.bits[Math.floor(i / 32)] = newBits;\n    };\n    /**\n     * Sets a range of bits.\n     *\n     * @param start start of range, inclusive.\n     * @param end end of range, exclusive\n     */\n    BitArray.prototype.setRange = function (start /*int*/, end /*int*/) {\n        if (end < start || start < 0 || end > this.size) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (end === start) {\n            return;\n        }\n        end--; // will be easier to treat this as the last actually set bit -- inclusive\n        var firstInt = Math.floor(start / 32);\n        var lastInt = Math.floor(end / 32);\n        var bits = this.bits;\n        for (var i = firstInt; i <= lastInt; i++) {\n            var firstBit = i > firstInt ? 0 : start & 0x1F;\n            var lastBit = i < lastInt ? 31 : end & 0x1F;\n            // Ones from firstBit to lastBit, inclusive\n            var mask = (2 << lastBit) - (1 << firstBit);\n            bits[i] |= mask;\n        }\n    };\n    /**\n     * Clears all bits (sets to false).\n     */\n    BitArray.prototype.clear = function () {\n        var max = this.bits.length;\n        var bits = this.bits;\n        for (var i = 0; i < max; i++) {\n            bits[i] = 0;\n        }\n    };\n    /**\n     * Efficient method to check if a range of bits is set, or not set.\n     *\n     * @param start start of range, inclusive.\n     * @param end end of range, exclusive\n     * @param value if true, checks that bits in range are set, otherwise checks that they are not set\n     * @return true iff all bits are set or not set in range, according to value argument\n     * @throws IllegalArgumentException if end is less than start or the range is not contained in the array\n     */\n    BitArray.prototype.isRange = function (start /*int*/, end /*int*/, value) {\n        if (end < start || start < 0 || end > this.size) {\n            throw new IllegalArgumentException_1.default();\n        }\n        if (end === start) {\n            return true; // empty range matches\n        }\n        end--; // will be easier to treat this as the last actually set bit -- inclusive\n        var firstInt = Math.floor(start / 32);\n        var lastInt = Math.floor(end / 32);\n        var bits = this.bits;\n        for (var i = firstInt; i <= lastInt; i++) {\n            var firstBit = i > firstInt ? 0 : start & 0x1F;\n            var lastBit = i < lastInt ? 31 : end & 0x1F;\n            // Ones from firstBit to lastBit, inclusive\n            var mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;\n            // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits\n            // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,\n            // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n            if ((bits[i] & mask) !== (value ? mask : 0)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    BitArray.prototype.appendBit = function (bit) {\n        this.ensureCapacity(this.size + 1);\n        if (bit) {\n            this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);\n        }\n        this.size++;\n    };\n    /**\n     * Appends the least-significant bits, from value, in order from most-significant to\n     * least-significant. For example, appending 6 bits from 0x000001E will append the bits\n     * 0, 1, 1, 1, 1, 0 in that order.\n     *\n     * @param value {@code int} containing bits to append\n     * @param numBits bits from value to append\n     */\n    BitArray.prototype.appendBits = function (value /*int*/, numBits /*int*/) {\n        if (numBits < 0 || numBits > 32) {\n            throw new IllegalArgumentException_1.default('Num bits must be between 0 and 32');\n        }\n        this.ensureCapacity(this.size + numBits);\n        // const appendBit = this.appendBit;\n        for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {\n            this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) === 1);\n        }\n    };\n    BitArray.prototype.appendBitArray = function (other) {\n        var otherSize = other.size;\n        this.ensureCapacity(this.size + otherSize);\n        // const appendBit = this.appendBit;\n        for (var i = 0; i < otherSize; i++) {\n            this.appendBit(other.get(i));\n        }\n    };\n    BitArray.prototype.xor = function (other) {\n        if (this.size !== other.size) {\n            throw new IllegalArgumentException_1.default('Sizes don\\'t match');\n        }\n        var bits = this.bits;\n        for (var i = 0, length_1 = bits.length; i < length_1; i++) {\n            // The last int could be incomplete (i.e. not have 32 bits in\n            // it) but there is no problem since 0 XOR 0 == 0.\n            bits[i] ^= other.bits[i];\n        }\n    };\n    /**\n     *\n     * @param bitOffset first bit to start writing\n     * @param array array to write into. Bytes are written most-significant byte first. This is the opposite\n     *  of the internal representation, which is exposed by {@link #getBitArray()}\n     * @param offset position in array to start writing\n     * @param numBytes how many bytes to write\n     */\n    BitArray.prototype.toBytes = function (bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {\n        for (var i = 0; i < numBytes; i++) {\n            var theByte = 0;\n            for (var j = 0; j < 8; j++) {\n                if (this.get(bitOffset)) {\n                    theByte |= 1 << (7 - j);\n                }\n                bitOffset++;\n            }\n            array[offset + i] = /*(byte)*/ theByte;\n        }\n    };\n    /**\n     * @return underlying array of ints. The first element holds the first 32 bits, and the least\n     *         significant bit is bit 0.\n     */\n    BitArray.prototype.getBitArray = function () {\n        return this.bits;\n    };\n    /**\n     * Reverses all bits in the array.\n     */\n    BitArray.prototype.reverse = function () {\n        var newBits = new Int32Array(this.bits.length);\n        // reverse all int's first\n        var len = Math.floor((this.size - 1) / 32);\n        var oldBitsLen = len + 1;\n        var bits = this.bits;\n        for (var i = 0; i < oldBitsLen; i++) {\n            var x = bits[i];\n            x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n            x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n            x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n            x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n            x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n            newBits[len - i] = /*(int)*/ x;\n        }\n        // now correct the int's if the bit size isn't a multiple of 32\n        if (this.size !== oldBitsLen * 32) {\n            var leftOffset = oldBitsLen * 32 - this.size;\n            var currentInt = newBits[0] >>> leftOffset;\n            for (var i = 1; i < oldBitsLen; i++) {\n                var nextInt = newBits[i];\n                currentInt |= nextInt << (32 - leftOffset);\n                newBits[i - 1] = currentInt;\n                currentInt = nextInt >>> leftOffset;\n            }\n            newBits[oldBitsLen - 1] = currentInt;\n        }\n        this.bits = newBits;\n    };\n    BitArray.makeArray = function (size /*int*/) {\n        return new Int32Array(Math.floor((size + 31) / 32));\n    };\n    /*@Override*/\n    BitArray.prototype.equals = function (o) {\n        if (!(o instanceof BitArray)) {\n            return false;\n        }\n        var other = o;\n        return this.size === other.size && Arrays_1.default.equals(this.bits, other.bits);\n    };\n    /*@Override*/\n    BitArray.prototype.hashCode = function () {\n        return 31 * this.size + Arrays_1.default.hashCode(this.bits);\n    };\n    /*@Override*/\n    BitArray.prototype.toString = function () {\n        var result = '';\n        for (var i = 0, size = this.size; i < size; i++) {\n            if ((i & 0x07) === 0) {\n                result += ' ';\n            }\n            result += this.get(i) ? 'X' : '.';\n        }\n        return result;\n    };\n    /*@Override*/\n    BitArray.prototype.clone = function () {\n        return new BitArray(this.size, this.bits.slice());\n    };\n    return BitArray;\n}());\nexports.default = BitArray;\n//# sourceMappingURL=BitArray.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","IllegalArgumentException_1","Arrays_1","Integer_1","System_1","BitArray","size","bits","undefined","Int32Array","makeArray","prototype","getSize","BitArray.prototype.getSize","getSizeInBytes","BitArray.prototype.getSizeInBytes","Math","floor","ensureCapacity","BitArray.prototype.ensureCapacity","length","newBits","default","arraycopy","get","BitArray.prototype.get","i","set","BitArray.prototype.set","flip","BitArray.prototype.flip","getNextSet","BitArray.prototype.getNextSet","from","bitsOffset","currentBits","result","numberOfTrailingZeros","getNextUnset","BitArray.prototype.getNextUnset","setBulk","BitArray.prototype.setBulk","setRange","BitArray.prototype.setRange","start","end","firstInt","lastInt","lastBit","firstBit","clear","BitArray.prototype.clear","max","isRange","BitArray.prototype.isRange","mask","appendBit","BitArray.prototype.appendBit","bit","appendBits","BitArray.prototype.appendBits","numBits","numBitsLeft","appendBitArray","BitArray.prototype.appendBitArray","other","otherSize","xor","BitArray.prototype.xor","length_1","toBytes","BitArray.prototype.toBytes","bitOffset","array","offset","numBytes","theByte","j","getBitArray","BitArray.prototype.getBitArray","reverse","BitArray.prototype.reverse","len","oldBitsLen","x","leftOffset","currentInt","nextInt","BitArray.makeArray","equals","BitArray.prototype.equals","o","hashCode","BitArray.prototype.hashCode","toString","BitArray.prototype.toString","clone","BitArray.prototype.clone","slice"]
}
