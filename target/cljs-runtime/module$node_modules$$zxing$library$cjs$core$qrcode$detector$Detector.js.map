{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$detector$Detector.js",
"lineCount":15,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/detector/Detector.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$detector$Detector\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\nvar DetectorResult_1 = require(\"../../common/DetectorResult\");\n// import GridSampler from '../../common/GridSampler';\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\nvar PerspectiveTransform_1 = require(\"../../common/PerspectiveTransform\");\nvar DecodeHintType_1 = require(\"../../DecodeHintType\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar Version_1 = require(\"../decoder/Version\");\nvar AlignmentPatternFinder_1 = require(\"./AlignmentPatternFinder\");\nvar FinderPatternFinder_1 = require(\"./FinderPatternFinder\");\n/*import java.util.Map;*/\n/**\n * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\nvar Detector = /** @class */ (function () {\n    function Detector(image) {\n        this.image = image;\n    }\n    Detector.prototype.getImage = function () {\n        return this.image;\n    };\n    Detector.prototype.getResultPointCallback = function () {\n        return this.resultPointCallback;\n    };\n    /**\n     * <p>Detects a QR Code in an image.</p>\n     *\n     * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n     * @throws NotFoundException if QR Code cannot be found\n     * @throws FormatException if a QR Code cannot be decoded\n     */\n    // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {\n    //   return detect(null)\n    // }\n    /**\n     * <p>Detects a QR Code in an image.</p>\n     *\n     * @param hints optional hints to detector\n     * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n     * @throws NotFoundException if QR Code cannot be found\n     * @throws FormatException if a QR Code cannot be decoded\n     */\n    Detector.prototype.detect = function (hints) {\n        this.resultPointCallback = (hints === null || hints === undefined) ? null :\n            /*(ResultPointCallback) */ hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n        var finder = new FinderPatternFinder_1.default(this.image, this.resultPointCallback);\n        var info = finder.find(hints);\n        return this.processFinderPatternInfo(info);\n    };\n    Detector.prototype.processFinderPatternInfo = function (info) {\n        var topLeft = info.getTopLeft();\n        var topRight = info.getTopRight();\n        var bottomLeft = info.getBottomLeft();\n        var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n        if (moduleSize < 1.0) {\n            throw new NotFoundException_1.default('No pattern found in proccess finder.');\n        }\n        var dimension = Detector.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n        var provisionalVersion = Version_1.default.getProvisionalVersionForDimension(dimension);\n        var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;\n        var alignmentPattern = null;\n        // Anything above version 1 has an alignment pattern\n        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {\n            // Guess where a \"bottom right\" finder pattern would have been\n            var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n            var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();\n            // Estimate that alignment pattern is closer by 3 modules\n            // from \"bottom right\" to known top left location\n            var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n            var estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));\n            var estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));\n            // Kind of arbitrary -- expand search radius before giving up\n            for (var i = 4; i <= 16; i <<= 1) {\n                try {\n                    alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n                    break;\n                }\n                catch (re /*NotFoundException*/) {\n                    if (!(re instanceof NotFoundException_1.default)) {\n                        throw re;\n                    }\n                    // try next round\n                }\n            }\n            // If we didn't find alignment pattern... well try anyway without it\n        }\n        var transform = Detector.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n        var bits = Detector.sampleGrid(this.image, transform, dimension);\n        var points;\n        if (alignmentPattern === null) {\n            points = [bottomLeft, topLeft, topRight];\n        }\n        else {\n            points = [bottomLeft, topLeft, topRight, alignmentPattern];\n        }\n        return new DetectorResult_1.default(bits, points);\n    };\n    Detector.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {\n        var dimMinusThree = dimension - 3.5;\n        var bottomRightX; /*float*/\n        var bottomRightY; /*float*/\n        var sourceBottomRightX; /*float*/\n        var sourceBottomRightY; /*float*/\n        if (alignmentPattern !== null) {\n            bottomRightX = alignmentPattern.getX();\n            bottomRightY = alignmentPattern.getY();\n            sourceBottomRightX = dimMinusThree - 3.0;\n            sourceBottomRightY = sourceBottomRightX;\n        }\n        else {\n            // Don't have an alignment pattern, just make up the bottom-right point\n            bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();\n            bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();\n            sourceBottomRightX = dimMinusThree;\n            sourceBottomRightY = dimMinusThree;\n        }\n        return PerspectiveTransform_1.default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());\n    };\n    Detector.sampleGrid = function (image, transform, dimension /*int*/) {\n        var sampler = GridSamplerInstance_1.default.getInstance();\n        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);\n    };\n    /**\n     * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position\n     * of the finder patterns and estimated module size.</p>\n     */\n    Detector.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize /*float*/) {\n        var tltrCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, topRight) / moduleSize);\n        var tlblCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, bottomLeft) / moduleSize);\n        var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;\n        switch (dimension & 0x03) { // mod 4\n            case 0:\n                dimension++;\n                break;\n            // 1? do nothing\n            case 2:\n                dimension--;\n                break;\n            case 3:\n                throw new NotFoundException_1.default('Dimensions could be not found.');\n        }\n        return dimension;\n    };\n    /**\n     * <p>Computes an average estimated module size based on estimated derived from the positions\n     * of the three finder patterns.</p>\n     *\n     * @param topLeft detected top-left finder pattern center\n     * @param topRight detected top-right finder pattern center\n     * @param bottomLeft detected bottom-left finder pattern center\n     * @return estimated module size\n     */\n    Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {\n        // Take the average\n        return (this.calculateModuleSizeOneWay(topLeft, topRight) +\n            this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n    };\n    /**\n     * <p>Estimates module size based on two finder patterns -- it uses\n     * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the\n     * width of each, measuring along the axis between their centers.</p>\n     */\n    Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {\n        var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()), \n        /*(int) */ Math.floor(pattern.getY()), \n        /*(int) */ Math.floor(otherPattern.getX()), \n        /*(int) */ Math.floor(otherPattern.getY()));\n        var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()), \n        /*(int) */ Math.floor(otherPattern.getY()), \n        /*(int) */ Math.floor(pattern.getX()), \n        /*(int) */ Math.floor(pattern.getY()));\n        if (isNaN(moduleSizeEst1)) {\n            return moduleSizeEst2 / 7.0;\n        }\n        if (isNaN(moduleSizeEst2)) {\n            return moduleSizeEst1 / 7.0;\n        }\n        // Average them, and divide by 7 since we've counted the width of 3 black modules,\n        // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n        return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n    };\n    /**\n     * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of\n     * a finder pattern by looking for a black-white-black run from the center in the direction\n     * of another point (another finder pattern center), and in the opposite direction too.\n     */\n    Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n        var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);\n        // Now count other way -- don't run off image though of course\n        var scale = 1.0;\n        var otherToX = fromX - (toX - fromX);\n        if (otherToX < 0) {\n            scale = fromX / /*(float) */ (fromX - otherToX);\n            otherToX = 0;\n        }\n        else if (otherToX >= this.image.getWidth()) {\n            scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);\n            otherToX = this.image.getWidth() - 1;\n        }\n        var otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);\n        scale = 1.0;\n        if (otherToY < 0) {\n            scale = fromY / /*(float) */ (fromY - otherToY);\n            otherToY = 0;\n        }\n        else if (otherToY >= this.image.getHeight()) {\n            scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);\n            otherToY = this.image.getHeight() - 1;\n        }\n        otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);\n        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\n        // Middle pixel is double-counted this way; subtract 1\n        return result - 1.0;\n    };\n    /**\n     * <p>This method traces a line from a point in the image, in the direction towards another point.\n     * It begins in a black region, and keeps going until it finds white, then black, then white again.\n     * It reports the distance from the start to this point.</p>\n     *\n     * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern\n     * may be skewed or rotated.</p>\n     */\n    Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n        // Mild variant of Bresenham's algorithm\n        // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n        if (steep) {\n            var temp = fromX;\n            fromX = fromY;\n            fromY = temp;\n            temp = toX;\n            toX = toY;\n            toY = temp;\n        }\n        var dx = Math.abs(toX - fromX);\n        var dy = Math.abs(toY - fromY);\n        var error = -dx / 2;\n        var xstep = fromX < toX ? 1 : -1;\n        var ystep = fromY < toY ? 1 : -1;\n        // In black pixels, looking for white, first or second time.\n        var state = 0;\n        // Loop up until x == toX, but not beyond\n        var xLimit = toX + xstep;\n        for (var x = fromX, y = fromY; x !== xLimit; x += xstep) {\n            var realX = steep ? y : x;\n            var realY = steep ? x : y;\n            // Does current pixel mean we have moved white to black or vice versa?\n            // Scanning black in state 0,2 and white in state 1, so if we find the wrong\n            // color, advance to next state or end if we are in state 2 already\n            if ((state === 1) === this.image.get(realX, realY)) {\n                if (state === 2) {\n                    return MathUtils_1.default.distance(x, y, fromX, fromY);\n                }\n                state++;\n            }\n            error += dy;\n            if (error > 0) {\n                if (y === toY) {\n                    break;\n                }\n                y += ystep;\n                error -= dx;\n            }\n        }\n        // Found black-white-black; give the benefit of the doubt that the next pixel outside the image\n        // is \"white\" so this last point at (toX+xStep,toY) is the right ending. This is really a\n        // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.\n        if (state === 2) {\n            return MathUtils_1.default.distance(toX + xstep, toY, fromX, fromY);\n        }\n        // else we didn't find even black-white-black; no estimate is really possible\n        return NaN;\n    };\n    /**\n     * <p>Attempts to locate an alignment pattern in a limited region of the image, which is\n     * guessed to contain it. This method uses {@link AlignmentPattern}.</p>\n     *\n     * @param overallEstModuleSize estimated module size so far\n     * @param estAlignmentX x coordinate of center of area probably containing alignment pattern\n     * @param estAlignmentY y coordinate of above\n     * @param allowanceFactor number of pixels in all directions to search from the center\n     * @return {@link AlignmentPattern} if found, or null otherwise\n     * @throws NotFoundException if an unexpected error occurs during detection\n     */\n    Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {\n        // Look for an alignment pattern (3 modules in size) around where it\n        // should be\n        var allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);\n        var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n        var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);\n        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n            throw new NotFoundException_1.default('Alignment top exceeds estimated module size.');\n        }\n        var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n        var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);\n        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {\n            throw new NotFoundException_1.default('Alignment bottom exceeds estimated module size.');\n        }\n        var alignmentFinder = new AlignmentPatternFinder_1.default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n        return alignmentFinder.find();\n    };\n    return Detector;\n}());\nexports.default = Detector;\n//# sourceMappingURL=Detector.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","MathUtils_1","DetectorResult_1","GridSamplerInstance_1","PerspectiveTransform_1","DecodeHintType_1","NotFoundException_1","ResultPoint_1","Version_1","AlignmentPatternFinder_1","FinderPatternFinder_1","Detector","image","prototype","getImage","Detector.prototype.getImage","getResultPointCallback","Detector.prototype.getResultPointCallback","resultPointCallback","detect","Detector.prototype.detect","hints","undefined","get","default","NEED_RESULT_POINT_CALLBACK","info","find","finder","processFinderPatternInfo","Detector.prototype.processFinderPatternInfo","topLeft","getTopLeft","topRight","getTopRight","bottomLeft","getBottomLeft","moduleSize","calculateModuleSize","dimension","computeDimension","provisionalVersion","getProvisionalVersionForDimension","modulesBetweenFPCenters","getDimensionForVersion","alignmentPattern","getAlignmentPatternCenters","length","bottomRightX","getX","bottomRightY","getY","correctionToTopLeft","estAlignmentX","Math","floor","estAlignmentY","i","findAlignmentInRegion","re","transform","createTransform","bits","sampleGrid","points","Detector.createTransform","dimMinusThree","sourceBottomRightX","sourceBottomRightY","quadrilateralToQuadrilateral","Detector.sampleGrid","getInstance","sampler","sampleGridWithTransform","Detector.computeDimension","tltrCentersDimension","round","distance","tlblCentersDimension","Detector.prototype.calculateModuleSize","calculateModuleSizeOneWay","Detector.prototype.calculateModuleSizeOneWay","pattern","otherPattern","moduleSizeEst1","sizeOfBlackWhiteBlackRunBothWays","moduleSizeEst2","isNaN","Detector.prototype.sizeOfBlackWhiteBlackRunBothWays","fromX","fromY","toX","toY","result","sizeOfBlackWhiteBlackRun","scale","otherToX","getWidth","otherToY","getHeight","Detector.prototype.sizeOfBlackWhiteBlackRun","steep","abs","temp","dx","dy","error","xstep","ystep","state","xLimit","x","y","realX","realY","NaN","Detector.prototype.findAlignmentInRegion","overallEstModuleSize","allowanceFactor","allowance","alignmentAreaLeftX","max","alignmentAreaRightX","min","alignmentAreaTopY","alignmentAreaBottomY","alignmentFinder"]
}
