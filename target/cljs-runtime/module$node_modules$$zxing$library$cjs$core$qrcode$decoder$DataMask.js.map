{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$DataMask.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/decoder/DataMask.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$DataMask\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataMaskValues = void 0;\nvar DataMaskValues;\n(function (DataMaskValues) {\n    DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\n    DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\n})(DataMaskValues = exports.DataMaskValues || (exports.DataMaskValues = {}));\n/**\n * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\n * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\n * including areas used for finder patterns, timing patterns, etc. These areas should be unused\n * after the point they are unmasked anyway.</p>\n *\n * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\n * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\n *\n * @author Sean Owen\n */\nvar DataMask = /** @class */ (function () {\n    // See ISO 18004:2006 6.8.1\n    function DataMask(value, isMasked) {\n        this.value = value;\n        this.isMasked = isMasked;\n    }\n    // End of enum constants.\n    /**\n     * <p>Implementations of this method reverse the data masking process applied to a QR Code and\n     * make its bits ready to read.</p>\n     *\n     * @param bits representation of QR Code bits\n     * @param dimension dimension of QR Code, represented by bits, being unmasked\n     */\n    DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {\n        for (var i = 0; i < dimension; i++) {\n            for (var j = 0; j < dimension; j++) {\n                if (this.isMasked(i, j)) {\n                    bits.flip(j, i);\n                }\n            }\n        }\n    };\n    DataMask.values = new Map([\n        /**\n         * 000: mask bits for which (x + y) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i /*int*/, j /*int*/) { return ((i + j) & 0x01) === 0; })],\n        /**\n         * 001: mask bits for which x mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i /*int*/, j /*int*/) { return (i & 0x01) === 0; })],\n        /**\n         * 010: mask bits for which y mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i /*int*/, j /*int*/) { return j % 3 === 0; })],\n        /**\n         * 011: mask bits for which (x + y) mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i /*int*/, j /*int*/) { return (i + j) % 3 === 0; })],\n        /**\n         * 100: mask bits for which (x/2 + y/3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i /*int*/, j /*int*/) { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],\n        /**\n         * 101: mask bits for which xy mod 2 + xy mod 3 == 0\n         * equivalently, such that xy mod 6 == 0\n         */\n        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i /*int*/, j /*int*/) { return (i * j) % 6 === 0; })],\n        /**\n         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that xy mod 6 < 3\n         */\n        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i /*int*/, j /*int*/) { return ((i * j) % 6) < 3; })],\n        /**\n         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that (x + y + xy mod 3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i /*int*/, j /*int*/) { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],\n    ]);\n    return DataMask;\n}());\nexports.default = DataMask;\n//# sourceMappingURL=DataMask.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","DataMaskValues","DataMask","isMasked","prototype","unmaskBitMatrix","DataMask.prototype.unmaskBitMatrix","bits","dimension","i","j","flip","values","Map","DATA_MASK_000","DATA_MASK_001","DATA_MASK_010","DATA_MASK_011","DATA_MASK_100","Math","floor","DATA_MASK_101","DATA_MASK_110","DATA_MASK_111","default"]
}
