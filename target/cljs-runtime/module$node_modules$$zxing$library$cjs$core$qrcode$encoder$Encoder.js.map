{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$encoder$Encoder.js",
"lineCount":28,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/encoder/Encoder.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$encoder$Encoder\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode.encoder {*/\nvar EncodeHintType_1 = require(\"../../EncodeHintType\");\nvar BitArray_1 = require(\"../../common/BitArray\");\nvar CharacterSetECI_1 = require(\"../../common/CharacterSetECI\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonEncoder_1 = require(\"../../common/reedsolomon/ReedSolomonEncoder\");\nvar Mode_1 = require(\"../decoder/Mode\");\nvar Version_1 = require(\"../decoder/Version\");\nvar MaskUtil_1 = require(\"./MaskUtil\");\nvar ByteMatrix_1 = require(\"./ByteMatrix\");\nvar QRCode_1 = require(\"./QRCode\");\nvar MatrixUtil_1 = require(\"./MatrixUtil\");\nvar StringEncoding_1 = require(\"../../util/StringEncoding\");\nvar BlockPair_1 = require(\"./BlockPair\");\nvar WriterException_1 = require(\"../../WriterException\");\n/*import java.io.UnsupportedEncodingException;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collection;*/\n/*import java.util.Map;*/\n/**\n * @author satorux@google.com (Satoru Takabayashi) - creator\n * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n */\nvar Encoder = /** @class */ (function () {\n    // TYPESCRIPTPORT: changed to UTF8, the default for js\n    function Encoder() {\n    }\n    // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\n    // Basically it applies four rules and summate all penalties.\n    Encoder.calculateMaskPenalty = function (matrix) {\n        return MaskUtil_1.default.applyMaskPenaltyRule1(matrix)\n            + MaskUtil_1.default.applyMaskPenaltyRule2(matrix)\n            + MaskUtil_1.default.applyMaskPenaltyRule3(matrix)\n            + MaskUtil_1.default.applyMaskPenaltyRule4(matrix);\n    };\n    /**\n     * @param content text to encode\n     * @param ecLevel error correction level to use\n     * @return {@link QRCode} representing the encoded QR code\n     * @throws WriterException if encoding can't succeed, because of for example invalid content\n     *   or configuration\n     */\n    // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\n    //   return encode(content, ecLevel, null)\n    // }\n    Encoder.encode = function (content, ecLevel, hints) {\n        if (hints === void 0) { hints = null; }\n        // Determine what character encoding has been specified by the caller, if any\n        var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\n        var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType_1.default.CHARACTER_SET);\n        if (hasEncodingHint) {\n            encoding = hints.get(EncodeHintType_1.default.CHARACTER_SET).toString();\n        }\n        // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n        // multiple modes / segments even if that were more efficient. Twould be nice.\n        var mode = this.chooseMode(content, encoding);\n        // This will store the header information, like mode and\n        // length, as well as \"header\" segments like an ECI segment.\n        var headerBits = new BitArray_1.default();\n        // Append ECI segment if applicable\n        if (mode === Mode_1.default.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\n            var eci = CharacterSetECI_1.default.getCharacterSetECIByName(encoding);\n            if (eci !== undefined) {\n                this.appendECI(eci, headerBits);\n            }\n        }\n        // (With ECI in place,) Write the mode marker\n        this.appendModeInfo(mode, headerBits);\n        // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n        // main payload yet.\n        var dataBits = new BitArray_1.default();\n        this.appendBytes(content, mode, dataBits, encoding);\n        var version;\n        if (hints !== null && undefined !== hints.get(EncodeHintType_1.default.QR_VERSION)) {\n            var versionNumber = Number.parseInt(hints.get(EncodeHintType_1.default.QR_VERSION).toString(), 10);\n            version = Version_1.default.getVersionForNumber(versionNumber);\n            var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\n            if (!this.willFit(bitsNeeded, version, ecLevel)) {\n                throw new WriterException_1.default('Data too big for requested version');\n            }\n        }\n        else {\n            version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\n        }\n        var headerAndDataBits = new BitArray_1.default();\n        headerAndDataBits.appendBitArray(headerBits);\n        // Find \"length\" of main segment and write it\n        var numLetters = mode === Mode_1.default.BYTE ? dataBits.getSizeInBytes() : content.length;\n        this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);\n        // Put data together into the overall payload\n        headerAndDataBits.appendBitArray(dataBits);\n        var ecBlocks = version.getECBlocksForLevel(ecLevel);\n        var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();\n        // Terminate the bits properly.\n        this.terminateBits(numDataBytes, headerAndDataBits);\n        // Interleave data bits with error correction code.\n        var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\n        var qrCode = new QRCode_1.default();\n        qrCode.setECLevel(ecLevel);\n        qrCode.setMode(mode);\n        qrCode.setVersion(version);\n        //  Choose the mask pattern and set to \"qrCode\".\n        var dimension = version.getDimensionForVersion();\n        var matrix = new ByteMatrix_1.default(dimension, dimension);\n        var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\n        qrCode.setMaskPattern(maskPattern);\n        // Build the matrix and set it to \"qrCode\".\n        MatrixUtil_1.default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\n        qrCode.setMatrix(matrix);\n        return qrCode;\n    };\n    /**\n     * Decides the smallest version of QR code that will contain all of the provided data.\n     *\n     * @throws WriterException if the data cannot fit in any version\n     */\n    Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {\n        // Hard part: need to know version to know how many bits length takes. But need to know how many\n        // bits it takes to know version. First we take a guess at version by assuming version will be\n        // the minimum, 1:\n        var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_1.default.getVersionForNumber(1));\n        var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);\n        // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\n        var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\n        return this.chooseVersion(bitsNeeded, ecLevel);\n    };\n    Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {\n        return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\n    };\n    /**\n     * @return the code point of the table used in alphanumeric mode or\n     *  -1 if there is no corresponding code in the table.\n     */\n    Encoder.getAlphanumericCode = function (code /*int*/) {\n        if (code < Encoder.ALPHANUMERIC_TABLE.length) {\n            return Encoder.ALPHANUMERIC_TABLE[code];\n        }\n        return -1;\n    };\n    // public static chooseMode(content: string): Mode {\n    //   return chooseMode(content, null);\n    // }\n    /**\n     * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\n     * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\n     */\n    Encoder.chooseMode = function (content, encoding) {\n        if (encoding === void 0) { encoding = null; }\n        if (CharacterSetECI_1.default.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\n            // Choose Kanji mode if all input are double-byte characters\n            return Mode_1.default.KANJI;\n        }\n        var hasNumeric = false;\n        var hasAlphanumeric = false;\n        for (var i = 0, length_1 = content.length; i < length_1; ++i) {\n            var c = content.charAt(i);\n            if (Encoder.isDigit(c)) {\n                hasNumeric = true;\n            }\n            else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\n                hasAlphanumeric = true;\n            }\n            else {\n                return Mode_1.default.BYTE;\n            }\n        }\n        if (hasAlphanumeric) {\n            return Mode_1.default.ALPHANUMERIC;\n        }\n        if (hasNumeric) {\n            return Mode_1.default.NUMERIC;\n        }\n        return Mode_1.default.BYTE;\n    };\n    Encoder.isOnlyDoubleByteKanji = function (content) {\n        var bytes;\n        try {\n            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS); // content.getBytes(\"Shift_JIS\"))\n        }\n        catch (ignored /*: UnsupportedEncodingException*/) {\n            return false;\n        }\n        var length = bytes.length;\n        if (length % 2 !== 0) {\n            return false;\n        }\n        for (var i = 0; i < length; i += 2) {\n            var byte1 = bytes[i] & 0xFF;\n            if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {\n        var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\n        var bestMaskPattern = -1;\n        // We try all mask patterns to choose the best one.\n        for (var maskPattern = 0; maskPattern < QRCode_1.default.NUM_MASK_PATTERNS; maskPattern++) {\n            MatrixUtil_1.default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\n            var penalty = this.calculateMaskPenalty(matrix);\n            if (penalty < minPenalty) {\n                minPenalty = penalty;\n                bestMaskPattern = maskPattern;\n            }\n        }\n        return bestMaskPattern;\n    };\n    Encoder.chooseVersion = function (numInputBits /*int*/, ecLevel) {\n        for (var versionNum = 1; versionNum <= 40; versionNum++) {\n            var version = Version_1.default.getVersionForNumber(versionNum);\n            if (Encoder.willFit(numInputBits, version, ecLevel)) {\n                return version;\n            }\n        }\n        throw new WriterException_1.default('Data too big');\n    };\n    /**\n     * @return true if the number of input bits will fit in a code with the specified version and\n     * error correction level.\n     */\n    Encoder.willFit = function (numInputBits /*int*/, version, ecLevel) {\n        // In the following comments, we use numbers of Version 7-H.\n        // numBytes = 196\n        var numBytes = version.getTotalCodewords();\n        // getNumECBytes = 130\n        var ecBlocks = version.getECBlocksForLevel(ecLevel);\n        var numEcBytes = ecBlocks.getTotalECCodewords();\n        // getNumDataBytes = 196 - 130 = 66\n        var numDataBytes = numBytes - numEcBytes;\n        var totalInputBytes = (numInputBits + 7) / 8;\n        return numDataBytes >= totalInputBytes;\n    };\n    /**\n     * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n     */\n    Encoder.terminateBits = function (numDataBytes /*int*/, bits) {\n        var capacity = numDataBytes * 8;\n        if (bits.getSize() > capacity) {\n            throw new WriterException_1.default('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +\n                capacity);\n        }\n        for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {\n            bits.appendBit(false);\n        }\n        // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\n        // If the last byte isn't 8-bit aligned, we'll add padding bits.\n        var numBitsInLastByte = bits.getSize() & 0x07;\n        if (numBitsInLastByte > 0) {\n            for (var i = numBitsInLastByte; i < 8; i++) {\n                bits.appendBit(false);\n            }\n        }\n        // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\n        var numPaddingBytes = numDataBytes - bits.getSizeInBytes();\n        for (var i = 0; i < numPaddingBytes; ++i) {\n            bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\n        }\n        if (bits.getSize() !== capacity) {\n            throw new WriterException_1.default('Bits size does not equal capacity');\n        }\n    };\n    /**\n     * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\n     * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\n     * JISX0510:2004 (p.30)\n     */\n    Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {\n        if (blockID >= numRSBlocks) {\n            throw new WriterException_1.default('Block ID too large');\n        }\n        // numRsBlocksInGroup2 = 196 % 5 = 1\n        var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;\n        // numRsBlocksInGroup1 = 5 - 1 = 4\n        var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;\n        // numTotalBytesInGroup1 = 196 / 5 = 39\n        var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);\n        // numTotalBytesInGroup2 = 39 + 1 = 40\n        var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;\n        // numDataBytesInGroup1 = 66 / 5 = 13\n        var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);\n        // numDataBytesInGroup2 = 13 + 1 = 14\n        var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;\n        // numEcBytesInGroup1 = 39 - 13 = 26\n        var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;\n        // numEcBytesInGroup2 = 40 - 14 = 26\n        var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\n        // Sanity checks.\n        // 26 = 26\n        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\n            throw new WriterException_1.default('EC bytes mismatch');\n        }\n        // 5 = 4 + 1.\n        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\n            throw new WriterException_1.default('RS blocks mismatch');\n        }\n        // 196 = (13 + 26) * 4 + (14 + 26) * 1\n        if (numTotalBytes !==\n            ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                numRsBlocksInGroup1) +\n                ((numDataBytesInGroup2 + numEcBytesInGroup2) *\n                    numRsBlocksInGroup2)) {\n            throw new WriterException_1.default('Total bytes mismatch');\n        }\n        if (blockID < numRsBlocksInGroup1) {\n            numDataBytesInBlock[0] = numDataBytesInGroup1;\n            numECBytesInBlock[0] = numEcBytesInGroup1;\n        }\n        else {\n            numDataBytesInBlock[0] = numDataBytesInGroup2;\n            numECBytesInBlock[0] = numEcBytesInGroup2;\n        }\n    };\n    /**\n     * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\n     * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\n     */\n    Encoder.interleaveWithECBytes = function (bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {\n        var e_1, _a, e_2, _b;\n        // \"bits\" must have \"getNumDataBytes\" bytes of data.\n        if (bits.getSizeInBytes() !== numDataBytes) {\n            throw new WriterException_1.default('Number of bits and data bytes does not match');\n        }\n        // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\n        // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\n        var dataBytesOffset = 0;\n        var maxNumDataBytes = 0;\n        var maxNumEcBytes = 0;\n        // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\n        var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\n        for (var i = 0; i < numRSBlocks; ++i) {\n            var numDataBytesInBlock = new Int32Array(1);\n            var numEcBytesInBlock = new Int32Array(1);\n            Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\n            var size = numDataBytesInBlock[0];\n            var dataBytes = new Uint8Array(size);\n            bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\n            var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\n            blocks.push(new BlockPair_1.default(dataBytes, ecBytes));\n            maxNumDataBytes = Math.max(maxNumDataBytes, size);\n            maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\n            dataBytesOffset += numDataBytesInBlock[0];\n        }\n        if (numDataBytes !== dataBytesOffset) {\n            throw new WriterException_1.default('Data bytes does not match offset');\n        }\n        var result = new BitArray_1.default();\n        // First, place data blocks.\n        for (var i = 0; i < maxNumDataBytes; ++i) {\n            try {\n                for (var blocks_1 = (e_1 = void 0, __values(blocks)), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {\n                    var block = blocks_1_1.value;\n                    var dataBytes = block.getDataBytes();\n                    if (i < dataBytes.length) {\n                        result.appendBits(dataBytes[i], 8);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        // Then, place error correction blocks.\n        for (var i = 0; i < maxNumEcBytes; ++i) {\n            try {\n                for (var blocks_2 = (e_2 = void 0, __values(blocks)), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {\n                    var block = blocks_2_1.value;\n                    var ecBytes = block.getErrorCorrectionBytes();\n                    if (i < ecBytes.length) {\n                        result.appendBits(ecBytes[i], 8);\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.\n            throw new WriterException_1.default('Interleaving error: ' + numTotalBytes + ' and ' +\n                result.getSizeInBytes() + ' differ.');\n        }\n        return result;\n    };\n    Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock /*int*/) {\n        var numDataBytes = dataBytes.length;\n        var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\n        for (var i = 0; i < numDataBytes; i++) {\n            toEncode[i] = dataBytes[i] & 0xFF;\n        }\n        new ReedSolomonEncoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\n        var ecBytes = new Uint8Array(numEcBytesInBlock);\n        for (var i = 0; i < numEcBytesInBlock; i++) {\n            ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];\n        }\n        return ecBytes;\n    };\n    /**\n     * Append mode info. On success, store the result in \"bits\".\n     */\n    Encoder.appendModeInfo = function (mode, bits) {\n        bits.appendBits(mode.getBits(), 4);\n    };\n    /**\n     * Append length info. On success, store the result in \"bits\".\n     */\n    Encoder.appendLengthInfo = function (numLetters /*int*/, version, mode, bits) {\n        var numBits = mode.getCharacterCountBits(version);\n        if (numLetters >= (1 << numBits)) {\n            throw new WriterException_1.default(numLetters + ' is bigger than ' + ((1 << numBits) - 1));\n        }\n        bits.appendBits(numLetters, numBits);\n    };\n    /**\n     * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\n     */\n    Encoder.appendBytes = function (content, mode, bits, encoding) {\n        switch (mode) {\n            case Mode_1.default.NUMERIC:\n                Encoder.appendNumericBytes(content, bits);\n                break;\n            case Mode_1.default.ALPHANUMERIC:\n                Encoder.appendAlphanumericBytes(content, bits);\n                break;\n            case Mode_1.default.BYTE:\n                Encoder.append8BitBytes(content, bits, encoding);\n                break;\n            case Mode_1.default.KANJI:\n                Encoder.appendKanjiBytes(content, bits);\n                break;\n            default:\n                throw new WriterException_1.default('Invalid mode: ' + mode);\n        }\n    };\n    Encoder.getDigit = function (singleCharacter) {\n        return singleCharacter.charCodeAt(0) - 48;\n    };\n    Encoder.isDigit = function (singleCharacter) {\n        var cn = Encoder.getDigit(singleCharacter);\n        return cn >= 0 && cn <= 9;\n    };\n    Encoder.appendNumericBytes = function (content, bits) {\n        var length = content.length;\n        var i = 0;\n        while (i < length) {\n            var num1 = Encoder.getDigit(content.charAt(i));\n            if (i + 2 < length) {\n                // Encode three numeric letters in ten bits.\n                var num2 = Encoder.getDigit(content.charAt(i + 1));\n                var num3 = Encoder.getDigit(content.charAt(i + 2));\n                bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n                i += 3;\n            }\n            else if (i + 1 < length) {\n                // Encode two numeric letters in seven bits.\n                var num2 = Encoder.getDigit(content.charAt(i + 1));\n                bits.appendBits(num1 * 10 + num2, 7);\n                i += 2;\n            }\n            else {\n                // Encode one numeric letter in four bits.\n                bits.appendBits(num1, 4);\n                i++;\n            }\n        }\n    };\n    Encoder.appendAlphanumericBytes = function (content, bits) {\n        var length = content.length;\n        var i = 0;\n        while (i < length) {\n            var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\n            if (code1 === -1) {\n                throw new WriterException_1.default();\n            }\n            if (i + 1 < length) {\n                var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\n                if (code2 === -1) {\n                    throw new WriterException_1.default();\n                }\n                // Encode two alphanumeric letters in 11 bits.\n                bits.appendBits(code1 * 45 + code2, 11);\n                i += 2;\n            }\n            else {\n                // Encode one alphanumeric letter in six bits.\n                bits.appendBits(code1, 6);\n                i++;\n            }\n        }\n    };\n    Encoder.append8BitBytes = function (content, bits, encoding) {\n        var bytes;\n        try {\n            bytes = StringEncoding_1.default.encode(content, encoding);\n        }\n        catch (uee /*: UnsupportedEncodingException*/) {\n            throw new WriterException_1.default(uee);\n        }\n        for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {\n            var b = bytes[i];\n            bits.appendBits(b, 8);\n        }\n    };\n    /**\n     * @throws WriterException\n     */\n    Encoder.appendKanjiBytes = function (content, bits) {\n        var bytes;\n        try {\n            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS);\n        }\n        catch (uee /*: UnsupportedEncodingException*/) {\n            throw new WriterException_1.default(uee);\n        }\n        var length = bytes.length;\n        for (var i = 0; i < length; i += 2) {\n            var byte1 = bytes[i] & 0xFF;\n            var byte2 = bytes[i + 1] & 0xFF;\n            var code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;\n            var subtracted = -1;\n            if (code >= 0x8140 && code <= 0x9ffc) {\n                subtracted = code - 0x8140;\n            }\n            else if (code >= 0xe040 && code <= 0xebbf) {\n                subtracted = code - 0xc140;\n            }\n            if (subtracted === -1) {\n                throw new WriterException_1.default('Invalid byte sequence');\n            }\n            var encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);\n            bits.appendBits(encoded, 13);\n        }\n    };\n    Encoder.appendECI = function (eci, bits) {\n        bits.appendBits(Mode_1.default.ECI.getBits(), 4);\n        // This is correct for values up to 127, which is all we need now.\n        bits.appendBits(eci.getValue(), 8);\n    };\n    // The original table is defined in the table 5 of JISX0510:2004 (p.19).\n    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n    ]);\n    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_1.default.UTF8.getName(); // \"ISO-8859-1\"\n    return Encoder;\n}());\nexports.default = Encoder;\n//# sourceMappingURL=Encoder.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","Object","defineProperty","EncodeHintType_1","BitArray_1","CharacterSetECI_1","GenericGF_1","ReedSolomonEncoder_1","Mode_1","Version_1","MaskUtil_1","ByteMatrix_1","QRCode_1","MatrixUtil_1","StringEncoding_1","BlockPair_1","WriterException_1","Encoder","calculateMaskPenalty","Encoder.calculateMaskPenalty","matrix","default","applyMaskPenaltyRule1","applyMaskPenaltyRule2","applyMaskPenaltyRule3","applyMaskPenaltyRule4","encode","Encoder.encode","content","ecLevel","hints","encoding","DEFAULT_BYTE_MODE_ENCODING","hasEncodingHint","undefined","get","CHARACTER_SET","toString","mode","chooseMode","headerBits","BYTE","eci","getCharacterSetECIByName","appendECI","appendModeInfo","dataBits","appendBytes","QR_VERSION","versionNumber","Number","parseInt","version","getVersionForNumber","bitsNeeded","calculateBitsNeeded","willFit","recommendVersion","headerAndDataBits","appendBitArray","numLetters","getSizeInBytes","appendLengthInfo","ecBlocks","getECBlocksForLevel","numDataBytes","getTotalCodewords","getTotalECCodewords","terminateBits","finalBits","interleaveWithECBytes","getNumBlocks","qrCode","setECLevel","setMode","setVersion","dimension","getDimensionForVersion","maskPattern","chooseMaskPattern","setMaskPattern","buildMatrix","setMatrix","Encoder.recommendVersion","provisionalBitsNeeded","provisionalVersion","chooseVersion","Encoder.calculateBitsNeeded","getSize","getCharacterCountBits","getAlphanumericCode","Encoder.getAlphanumericCode","code","ALPHANUMERIC_TABLE","Encoder.chooseMode","SJIS","getName","isOnlyDoubleByteKanji","KANJI","hasAlphanumeric","hasNumeric","length_1","c","charAt","isDigit","charCodeAt","ALPHANUMERIC","NUMERIC","Encoder.isOnlyDoubleByteKanji","bytes","ignored","byte1","Encoder.chooseMaskPattern","bits","minPenalty","MAX_SAFE_INTEGER","bestMaskPattern","NUM_MASK_PATTERNS","penalty","Encoder.chooseVersion","numInputBits","versionNum","Encoder.willFit","numBytes","numEcBytes","Encoder.terminateBits","capacity","appendBit","numBitsInLastByte","numPaddingBytes","appendBits","getNumDataBytesAndNumECBytesForBlockID","Encoder.getNumDataBytesAndNumECBytesForBlockID","numTotalBytes","numRSBlocks","blockID","numDataBytesInBlock","numECBytesInBlock","numRsBlocksInGroup2","numRsBlocksInGroup1","numTotalBytesInGroup1","Math","floor","numDataBytesInGroup1","numDataBytesInGroup2","numEcBytesInGroup1","numEcBytesInGroup2","Encoder.interleaveWithECBytes","e_1","_a","e_2","_b","dataBytesOffset","maxNumDataBytes","maxNumEcBytes","blocks","Int32Array","numEcBytesInBlock","size","dataBytes","Uint8Array","toBytes","ecBytes","generateECBytes","push","max","result","blocks_1","blocks_1_1","block","getDataBytes","e_1_1","error","return","blocks_2","blocks_2_1","getErrorCorrectionBytes","e_2_1","Encoder.generateECBytes","toEncode","QR_CODE_FIELD_256","Encoder.appendModeInfo","getBits","Encoder.appendLengthInfo","numBits","Encoder.appendBytes","appendNumericBytes","appendAlphanumericBytes","append8BitBytes","appendKanjiBytes","getDigit","Encoder.getDigit","singleCharacter","Encoder.isDigit","cn","Encoder.appendNumericBytes","num1","num2","num3","Encoder.appendAlphanumericBytes","code1","code2","Encoder.append8BitBytes","uee","length_2","b","Encoder.appendKanjiBytes","subtracted","Encoder.appendECI","ECI","getValue","from","UTF8"]
}
