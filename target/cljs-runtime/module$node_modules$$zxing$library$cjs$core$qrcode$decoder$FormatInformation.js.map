{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$FormatInformation.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/decoder/FormatInformation.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$FormatInformation\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode.decoder {*/\nvar ErrorCorrectionLevel_1 = require(\"./ErrorCorrectionLevel\");\nvar Integer_1 = require(\"../../util/Integer\");\n/**\n * <p>Encapsulates a QR Code's format information, including the data mask used and\n * error correction level.</p>\n *\n * @author Sean Owen\n * @see DataMask\n * @see ErrorCorrectionLevel\n */\nvar FormatInformation = /** @class */ (function () {\n    function FormatInformation(formatInfo /*int*/) {\n        // Bits 3,4\n        this.errorCorrectionLevel = ErrorCorrectionLevel_1.default.forBits((formatInfo >> 3) & 0x03);\n        // Bottom 3 bits\n        this.dataMask = /*(byte) */ (formatInfo & 0x07);\n    }\n    FormatInformation.numBitsDiffering = function (a /*int*/, b /*int*/) {\n        return Integer_1.default.bitCount(a ^ b);\n    };\n    /**\n     * @param maskedFormatInfo1 format info indicator, with mask still applied\n     * @param maskedFormatInfo2 second copy of same info; both are checked at the same time\n     *  to establish best match\n     * @return information about the format it specifies, or {@code null}\n     *  if doesn't seem to match any known pattern\n     */\n    FormatInformation.decodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\n        var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);\n        if (formatInfo !== null) {\n            return formatInfo;\n        }\n        // Should return null, but, some QR codes apparently\n        // do not mask this info. Try again by actually masking the pattern\n        // first\n        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);\n    };\n    FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\n        var e_1, _a;\n        // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing\n        var bestDifference = Number.MAX_SAFE_INTEGER;\n        var bestFormatInfo = 0;\n        try {\n            for (var _b = __values(FormatInformation.FORMAT_INFO_DECODE_LOOKUP), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var decodeInfo = _c.value;\n                var targetInfo = decodeInfo[0];\n                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {\n                    // Found an exact match\n                    return new FormatInformation(decodeInfo[1]);\n                }\n                var bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);\n                if (bitsDifference < bestDifference) {\n                    bestFormatInfo = decodeInfo[1];\n                    bestDifference = bitsDifference;\n                }\n                if (maskedFormatInfo1 !== maskedFormatInfo2) {\n                    // also try the other option\n                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);\n                    if (bitsDifference < bestDifference) {\n                        bestFormatInfo = decodeInfo[1];\n                        bestDifference = bitsDifference;\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits\n        // differing means we found a match\n        if (bestDifference <= 3) {\n            return new FormatInformation(bestFormatInfo);\n        }\n        return null;\n    };\n    FormatInformation.prototype.getErrorCorrectionLevel = function () {\n        return this.errorCorrectionLevel;\n    };\n    FormatInformation.prototype.getDataMask = function () {\n        return this.dataMask;\n    };\n    /*@Override*/\n    FormatInformation.prototype.hashCode = function () {\n        return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;\n    };\n    /*@Override*/\n    FormatInformation.prototype.equals = function (o) {\n        if (!(o instanceof FormatInformation)) {\n            return false;\n        }\n        var other = o;\n        return this.errorCorrectionLevel === other.errorCorrectionLevel &&\n            this.dataMask === other.dataMask;\n    };\n    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;\n    /**\n     * See ISO 18004:2006, Annex C, Table C.1\n     */\n    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [\n        Int32Array.from([0x5412, 0x00]),\n        Int32Array.from([0x5125, 0x01]),\n        Int32Array.from([0x5E7C, 0x02]),\n        Int32Array.from([0x5B4B, 0x03]),\n        Int32Array.from([0x45F9, 0x04]),\n        Int32Array.from([0x40CE, 0x05]),\n        Int32Array.from([0x4F97, 0x06]),\n        Int32Array.from([0x4AA0, 0x07]),\n        Int32Array.from([0x77C4, 0x08]),\n        Int32Array.from([0x72F3, 0x09]),\n        Int32Array.from([0x7DAA, 0x0A]),\n        Int32Array.from([0x789D, 0x0B]),\n        Int32Array.from([0x662F, 0x0C]),\n        Int32Array.from([0x6318, 0x0D]),\n        Int32Array.from([0x6C41, 0x0E]),\n        Int32Array.from([0x6976, 0x0F]),\n        Int32Array.from([0x1689, 0x10]),\n        Int32Array.from([0x13BE, 0x11]),\n        Int32Array.from([0x1CE7, 0x12]),\n        Int32Array.from([0x19D0, 0x13]),\n        Int32Array.from([0x0762, 0x14]),\n        Int32Array.from([0x0255, 0x15]),\n        Int32Array.from([0x0D0C, 0x16]),\n        Int32Array.from([0x083B, 0x17]),\n        Int32Array.from([0x355F, 0x18]),\n        Int32Array.from([0x3068, 0x19]),\n        Int32Array.from([0x3F31, 0x1A]),\n        Int32Array.from([0x3A06, 0x1B]),\n        Int32Array.from([0x24B4, 0x1C]),\n        Int32Array.from([0x2183, 0x1D]),\n        Int32Array.from([0x2EDA, 0x1E]),\n        Int32Array.from([0x2BED, 0x1F]),\n    ];\n    return FormatInformation;\n}());\nexports.default = FormatInformation;\n//# sourceMappingURL=FormatInformation.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","Object","defineProperty","ErrorCorrectionLevel_1","Integer_1","FormatInformation","formatInfo","errorCorrectionLevel","default","forBits","dataMask","numBitsDiffering","FormatInformation.numBitsDiffering","a","b","bitCount","decodeFormatInformation","FormatInformation.decodeFormatInformation","maskedFormatInfo1","maskedFormatInfo2","doDecodeFormatInformation","FORMAT_INFO_MASK_QR","FormatInformation.doDecodeFormatInformation","_a","bestDifference","Number","MAX_SAFE_INTEGER","bestFormatInfo","_b","FORMAT_INFO_DECODE_LOOKUP","_c","decodeInfo","targetInfo","bitsDifference","e_1_1","e_1","error","return","prototype","getErrorCorrectionLevel","FormatInformation.prototype.getErrorCorrectionLevel","getDataMask","FormatInformation.prototype.getDataMask","hashCode","FormatInformation.prototype.hashCode","getBits","equals","FormatInformation.prototype.equals","Int32Array","from"]
}
