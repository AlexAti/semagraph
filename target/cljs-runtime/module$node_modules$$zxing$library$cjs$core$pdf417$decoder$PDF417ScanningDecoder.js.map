{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$pdf417$decoder$PDF417ScanningDecoder.js",
"lineCount":38,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/pdf417/decoder/PDF417ScanningDecoder.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$pdf417$decoder$PDF417ScanningDecoder\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n* Copyright 2013 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// package com.google.zxing.pdf417.decoder;\n// import com.google.zxing.ChecksumException;\nvar ChecksumException_1 = require(\"../../ChecksumException\");\n// import com.google.zxing.FormatException;\nvar FormatException_1 = require(\"../../FormatException\");\n// import com.google.zxing.NotFoundException;\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n// import com.google.zxing.common.detector.MathUtils;\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = require(\"../PDF417Common\");\n// import com.google.zxing.pdf417.decoder.ec.ErrorCorrection;\nvar ErrorCorrection_1 = require(\"./ec/ErrorCorrection\");\n// local\nvar BoundingBox_1 = require(\"./BoundingBox\");\nvar DetectionResultRowIndicatorColumn_1 = require(\"./DetectionResultRowIndicatorColumn\");\nvar DetectionResult_1 = require(\"./DetectionResult\");\nvar DetectionResultColumn_1 = require(\"./DetectionResultColumn\");\nvar Codeword_1 = require(\"./Codeword\");\nvar BarcodeValue_1 = require(\"./BarcodeValue\");\nvar PDF417CodewordDecoder_1 = require(\"./PDF417CodewordDecoder\");\nvar DecodedBitStreamParser_1 = require(\"./DecodedBitStreamParser\");\n// utils\nvar Formatter_1 = require(\"../../util/Formatter\");\n// import java.util.ArrayList;\n// import java.util.Collection;\n// import java.util.Formatter;\n// import java.util.List;\n/**\n * @author Guenther Grau\n */\nvar PDF417ScanningDecoder = /** @class */ (function () {\n    function PDF417ScanningDecoder() {\n    }\n    /**\n     * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern\n     *\n     * columns. That way width can be deducted from the pattern column.\n     * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider\n     * than it should be. This can happen if the scanner used a bad blackpoint.\n     *\n     * @param BitMatrix\n     * @param image\n     * @param ResultPoint\n     * @param imageTopLeft\n     * @param ResultPoint\n     * @param imageBottomLeft\n     * @param ResultPoint\n     * @param imageTopRight\n     * @param ResultPoint\n     * @param imageBottomRight\n     * @param int\n     * @param minCodewordWidth\n     * @param int\n     * @param maxCodewordWidth\n     *\n     * @throws NotFoundException\n     * @throws FormatException\n     * @throws ChecksumException\n     */\n    PDF417ScanningDecoder.decode = function (image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {\n        var boundingBox = new BoundingBox_1.default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);\n        var leftRowIndicatorColumn = null;\n        var rightRowIndicatorColumn = null;\n        var detectionResult;\n        for (var firstPass /*boolean*/ = true;; firstPass = false) {\n            if (imageTopLeft != null) {\n                leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);\n            }\n            if (imageTopRight != null) {\n                rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);\n            }\n            detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);\n            if (detectionResult == null) {\n                throw NotFoundException_1.default.getNotFoundInstance();\n            }\n            var resultBox = detectionResult.getBoundingBox();\n            if (firstPass && resultBox != null &&\n                (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {\n                boundingBox = resultBox;\n            }\n            else {\n                break;\n            }\n        }\n        detectionResult.setBoundingBox(boundingBox);\n        var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;\n        detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);\n        detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);\n        var leftToRight = leftRowIndicatorColumn != null;\n        for (var barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {\n            var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;\n            if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {\n                // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.\n                continue;\n            }\n            var detectionResultColumn = void 0;\n            if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {\n                detectionResultColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, barcodeColumn === 0);\n            }\n            else {\n                detectionResultColumn = new DetectionResultColumn_1.default(boundingBox);\n            }\n            detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);\n            var startColumn = -1;\n            var previousStartColumn = startColumn;\n            // TODO start at a row for which we know the start position, then detect upwards and downwards from there.\n            for (var imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {\n                startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);\n                if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {\n                    if (previousStartColumn === -1) {\n                        continue;\n                    }\n                    startColumn = previousStartColumn;\n                }\n                var codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                if (codeword != null) {\n                    detectionResultColumn.setCodeword(imageRow, codeword);\n                    previousStartColumn = startColumn;\n                    minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());\n                    maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());\n                }\n            }\n        }\n        return PDF417ScanningDecoder.createDecoderResult(detectionResult);\n    };\n    /**\n     *\n     * @param leftRowIndicatorColumn\n     * @param rightRowIndicatorColumn\n     *\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.merge = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n        if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {\n            return null;\n        }\n        var barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);\n        if (barcodeMetadata == null) {\n            return null;\n        }\n        var boundingBox = BoundingBox_1.default.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));\n        return new DetectionResult_1.default(barcodeMetadata, boundingBox);\n    };\n    /**\n     *\n     * @param rowIndicatorColumn\n     *\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.adjustBoundingBox = function (rowIndicatorColumn) {\n        var e_1, _a;\n        if (rowIndicatorColumn == null) {\n            return null;\n        }\n        var rowHeights = rowIndicatorColumn.getRowHeights();\n        if (rowHeights == null) {\n            return null;\n        }\n        var maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);\n        var missingStartRows = 0;\n        try {\n            for (var rowHeights_1 = __values(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {\n                var rowHeight = rowHeights_1_1.value /*int*/;\n                missingStartRows += maxRowHeight - rowHeight;\n                if (rowHeight > 0) {\n                    break;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return)) _a.call(rowHeights_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var codewords = rowIndicatorColumn.getCodewords();\n        for (var row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {\n            missingStartRows--;\n        }\n        var missingEndRows = 0;\n        for (var row /*int*/ = rowHeights.length - 1; row >= 0; row--) {\n            missingEndRows += maxRowHeight - rowHeights[row];\n            if (rowHeights[row] > 0) {\n                break;\n            }\n        }\n        for (var row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {\n            missingEndRows--;\n        }\n        return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());\n    };\n    PDF417ScanningDecoder.getMax = function (values) {\n        var e_2, _a;\n        var maxValue = -1;\n        try {\n            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\n                var value = values_1_1.value /*int*/;\n                maxValue = Math.max(maxValue, value);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return maxValue;\n    };\n    PDF417ScanningDecoder.getBarcodeMetadata = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {\n        var leftBarcodeMetadata;\n        if (leftRowIndicatorColumn == null ||\n            (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {\n            return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();\n        }\n        var rightBarcodeMetadata;\n        if (rightRowIndicatorColumn == null ||\n            (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {\n            return leftBarcodeMetadata;\n        }\n        if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() &&\n            leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() &&\n            leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {\n            return null;\n        }\n        return leftBarcodeMetadata;\n    };\n    PDF417ScanningDecoder.getRowIndicatorColumn = function (image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {\n        var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, leftToRight);\n        for (var i /*int*/ = 0; i < 2; i++) {\n            var increment = i === 0 ? 1 : -1;\n            var startColumn = Math.trunc(Math.trunc(startPoint.getX()));\n            for (var imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() &&\n                imageRow >= boundingBox.getMinY(); imageRow += increment) {\n                var codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                if (codeword != null) {\n                    rowIndicatorColumn.setCodeword(imageRow, codeword);\n                    if (leftToRight) {\n                        startColumn = codeword.getStartX();\n                    }\n                    else {\n                        startColumn = codeword.getEndX();\n                    }\n                }\n            }\n        }\n        return rowIndicatorColumn;\n    };\n    /**\n     *\n     * @param detectionResult\n     * @param BarcodeValue\n     * @param param2\n     * @param param3\n     * @param barcodeMatrix\n     *\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.adjustCodewordCount = function (detectionResult, barcodeMatrix) {\n        var barcodeMatrix01 = barcodeMatrix[0][1];\n        var numberOfCodewords = barcodeMatrix01.getValue();\n        var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() *\n            detectionResult.getBarcodeRowCount() -\n            PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());\n        if (numberOfCodewords.length === 0) {\n            if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE) {\n                throw NotFoundException_1.default.getNotFoundInstance();\n            }\n            barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n        }\n        else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {\n            // The calculated one is more reliable as it is derived from the row indicator columns\n            barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n        }\n    };\n    /**\n     *\n     * @param detectionResult\n     *\n     * @throws FormatException\n     * @throws ChecksumException\n     * @throws NotFoundException\n     */\n    PDF417ScanningDecoder.createDecoderResult = function (detectionResult) {\n        var barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);\n        PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);\n        var erasures /*Collection<Integer>*/ = new Array();\n        var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());\n        var ambiguousIndexValuesList = /*List<int[]>*/ [];\n        var ambiguousIndexesList = /*Collection<Integer>*/ new Array();\n        for (var row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {\n            for (var column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {\n                var values = barcodeMatrix[row][column + 1].getValue();\n                var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;\n                if (values.length === 0) {\n                    erasures.push(codewordIndex);\n                }\n                else if (values.length === 1) {\n                    codewords[codewordIndex] = values[0];\n                }\n                else {\n                    ambiguousIndexesList.push(codewordIndex);\n                    ambiguousIndexValuesList.push(values);\n                }\n            }\n        }\n        var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);\n        for (var i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {\n            ambiguousIndexValues[i] = ambiguousIndexValuesList[i];\n        }\n        return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_1.default.toIntArray(erasures), PDF417Common_1.default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);\n    };\n    /**\n     * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The\n     * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value\n     * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of\n     * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the\n     * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,\n     * so decoding the normal barcodes is not affected by this.\n     *\n     * @param erasureArray contains the indexes of erasures\n     * @param ambiguousIndexes array with the indexes that have more than one most likely value\n     * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must\n     * be the same length as the ambiguousIndexes array\n     *\n     * @throws FormatException\n     * @throws ChecksumException\n     */\n    PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues = function (ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {\n        var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);\n        var tries = 100;\n        while (tries-- > 0) {\n            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];\n            }\n            try {\n                return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);\n            }\n            catch (err) {\n                var ignored = err instanceof ChecksumException_1.default;\n                if (!ignored) {\n                    throw err;\n                }\n            }\n            if (ambiguousIndexCount.length === 0) {\n                throw ChecksumException_1.default.getChecksumInstance();\n            }\n            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {\n                    ambiguousIndexCount[i]++;\n                    break;\n                }\n                else {\n                    ambiguousIndexCount[i] = 0;\n                    if (i === ambiguousIndexCount.length - 1) {\n                        throw ChecksumException_1.default.getChecksumInstance();\n                    }\n                }\n            }\n        }\n        throw ChecksumException_1.default.getChecksumInstance();\n    };\n    PDF417ScanningDecoder.createBarcodeMatrix = function (detectionResult) {\n        var e_3, _a, e_4, _b;\n        // let barcodeMatrix: BarcodeValue[][] =\n        // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];\n        var barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, function () { return new Array(detectionResult.getBarcodeColumnCount() + 2); });\n        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n            for (var column_1 /*int*/ = 0; column_1 < barcodeMatrix[row].length; column_1++) {\n                barcodeMatrix[row][column_1] = new BarcodeValue_1.default();\n            }\n        }\n        var column = 0;\n        try {\n            for (var _c = __values(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var detectionResultColumn = _d.value /*DetectionResultColumn*/;\n                if (detectionResultColumn != null) {\n                    try {\n                        for (var _e = (e_4 = void 0, __values(detectionResultColumn.getCodewords())), _f = _e.next(); !_f.done; _f = _e.next()) {\n                            var codeword = _f.value /*Codeword*/;\n                            if (codeword != null) {\n                                var rowNumber = codeword.getRowNumber();\n                                if (rowNumber >= 0) {\n                                    if (rowNumber >= barcodeMatrix.length) {\n                                        // We have more rows than the barcode metadata allows for, ignore them.\n                                        continue;\n                                    }\n                                    barcodeMatrix[rowNumber][column].setValue(codeword.getValue());\n                                }\n                            }\n                        }\n                    }\n                    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                    finally {\n                        try {\n                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                        }\n                        finally { if (e_4) throw e_4.error; }\n                    }\n                }\n                column++;\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return barcodeMatrix;\n    };\n    PDF417ScanningDecoder.isValidBarcodeColumn = function (detectionResult, barcodeColumn) {\n        return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;\n    };\n    PDF417ScanningDecoder.getStartColumn = function (detectionResult, barcodeColumn, imageRow, leftToRight) {\n        var e_5, _a;\n        var offset = leftToRight ? 1 : -1;\n        var codeword = null;\n        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);\n        }\n        if (codeword != null) {\n            return leftToRight ? codeword.getEndX() : codeword.getStartX();\n        }\n        codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);\n        if (codeword != null) {\n            return leftToRight ? codeword.getStartX() : codeword.getEndX();\n        }\n        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);\n        }\n        if (codeword != null) {\n            return leftToRight ? codeword.getEndX() : codeword.getStartX();\n        }\n        var skippedColumns = 0;\n        while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n            barcodeColumn -= offset;\n            try {\n                for (var _b = (e_5 = void 0, __values(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords())), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var previousRowCodeword = _c.value /*Codeword*/;\n                    if (previousRowCodeword != null) {\n                        return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) +\n                            offset *\n                                skippedColumns *\n                                (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());\n                    }\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n            skippedColumns++;\n        }\n        return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();\n    };\n    PDF417ScanningDecoder.detectCodeword = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {\n        startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n        // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length\n        // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.\n        // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate\n        // for the current position\n        var moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n        if (moduleBitCount == null) {\n            return null;\n        }\n        var endColumn;\n        var codewordBitCount = MathUtils_1.default.sum(moduleBitCount);\n        if (leftToRight) {\n            endColumn = startColumn + codewordBitCount;\n        }\n        else {\n            for (var i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {\n                var tmpCount = moduleBitCount[i];\n                moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];\n                moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;\n            }\n            endColumn = startColumn;\n            startColumn = endColumn - codewordBitCount;\n        }\n        // TODO implement check for width and correction of black and white bars\n        // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.\n        // should probably done only for codewords with a lot more than 17 bits.\n        // The following fixes 10-1.png, which has wide black bars and small white bars\n        //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {\n        //      if (i % 2 === 0) {\n        //        moduleBitCount[i]--;\n        //      } else {\n        //        moduleBitCount[i]++;\n        //      }\n        //    }\n        // We could also use the width of surrounding codewords for more accurate results, but this seems\n        // sufficient for now\n        if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {\n            // We could try to use the startX and endX position of the codeword in the same column in the previous row,\n            // create the bit count from it and normalize it to 8. This would help with single pixel errors.\n            return null;\n        }\n        var decodedValue = PDF417CodewordDecoder_1.default.getDecodedValue(moduleBitCount);\n        var codeword = PDF417Common_1.default.getCodeword(decodedValue);\n        if (codeword === -1) {\n            return null;\n        }\n        return new Codeword_1.default(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);\n    };\n    PDF417ScanningDecoder.getModuleBitCount = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {\n        var imageColumn = startColumn;\n        var moduleBitCount = new Int32Array(8);\n        var moduleNumber = 0;\n        var increment = leftToRight ? 1 : -1;\n        var previousPixelValue = leftToRight;\n        while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) &&\n            moduleNumber < moduleBitCount.length) {\n            if (image.get(imageColumn, imageRow) === previousPixelValue) {\n                moduleBitCount[moduleNumber]++;\n                imageColumn += increment;\n            }\n            else {\n                moduleNumber++;\n                previousPixelValue = !previousPixelValue;\n            }\n        }\n        if (moduleNumber === moduleBitCount.length ||\n            ((imageColumn === (leftToRight ? maxColumn : minColumn)) &&\n                moduleNumber === moduleBitCount.length - 1)) {\n            return moduleBitCount;\n        }\n        return null;\n    };\n    PDF417ScanningDecoder.getNumberOfECCodeWords = function (barcodeECLevel) {\n        return 2 << barcodeECLevel;\n    };\n    PDF417ScanningDecoder.adjustCodewordStartColumn = function (image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {\n        var correctedStartColumn = codewordStartColumn;\n        var increment = leftToRight ? -1 : 1;\n        // there should be no black pixels before the start column. If there are, then we need to start earlier.\n        for (var i /*int*/ = 0; i < 2; i++) {\n            while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) &&\n                leftToRight === image.get(correctedStartColumn, imageRow)) {\n                if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {\n                    return codewordStartColumn;\n                }\n                correctedStartColumn += increment;\n            }\n            increment = -increment;\n            leftToRight = !leftToRight;\n        }\n        return correctedStartColumn;\n    };\n    PDF417ScanningDecoder.checkCodewordSkew = function (codewordSize, minCodewordWidth, maxCodewordWidth) {\n        return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize &&\n            codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;\n    };\n    /**\n     * @throws FormatException,\n     * @throws ChecksumException\n     */\n    PDF417ScanningDecoder.decodeCodewords = function (codewords, ecLevel, erasures) {\n        if (codewords.length === 0) {\n            throw FormatException_1.default.getFormatInstance();\n        }\n        var numECCodewords = 1 << (ecLevel + 1);\n        var correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);\n        PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);\n        // Decode the codewords\n        var decoderResult = DecodedBitStreamParser_1.default.decode(codewords, '' + ecLevel);\n        decoderResult.setErrorsCorrected(correctedErrorsCount);\n        decoderResult.setErasures(erasures.length);\n        return decoderResult;\n    };\n    /**\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n     * correct the errors in-place.</p>\n     *\n     * @param codewords   data and error correction codewords\n     * @param erasures positions of any known erasures\n     * @param numECCodewords number of error correction codewords that are available in codewords\n     * @throws ChecksumException if error correction fails\n     */\n    PDF417ScanningDecoder.correctErrors = function (codewords, erasures, numECCodewords) {\n        if (erasures != null &&\n            erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS ||\n            numECCodewords < 0 ||\n            numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {\n            // Too many errors or EC Codewords is corrupted\n            throw ChecksumException_1.default.getChecksumInstance();\n        }\n        return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);\n    };\n    /**\n     * Verify that all is OK with the codeword array.\n     * @throws FormatException\n     */\n    PDF417ScanningDecoder.verifyCodewordCount = function (codewords, numECCodewords) {\n        if (codewords.length < 4) {\n            // Codeword array size should be at least 4 allowing for\n            // Count CW, At least one Data CW, Error Correction CW, Error Correction CW\n            throw FormatException_1.default.getFormatInstance();\n        }\n        // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data\n        // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad\n        // codewords, but excluding the number of error correction codewords.\n        var numberOfCodewords = codewords[0];\n        if (numberOfCodewords > codewords.length) {\n            throw FormatException_1.default.getFormatInstance();\n        }\n        if (numberOfCodewords === 0) {\n            // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)\n            if (numECCodewords < codewords.length) {\n                codewords[0] = codewords.length - numECCodewords;\n            }\n            else {\n                throw FormatException_1.default.getFormatInstance();\n            }\n        }\n    };\n    PDF417ScanningDecoder.getBitCountForCodeword = function (codeword) {\n        var result = new Int32Array(8);\n        var previousValue = 0;\n        var i = result.length - 1;\n        while (true) {\n            if ((codeword & 0x1) !== previousValue) {\n                previousValue = codeword & 0x1;\n                i--;\n                if (i < 0) {\n                    break;\n                }\n            }\n            result[i]++;\n            codeword >>= 1;\n        }\n        return result;\n    };\n    PDF417ScanningDecoder.getCodewordBucketNumber = function (codeword) {\n        if (codeword instanceof Int32Array) {\n            return this.getCodewordBucketNumber_Int32Array(codeword);\n        }\n        return this.getCodewordBucketNumber_number(codeword);\n    };\n    PDF417ScanningDecoder.getCodewordBucketNumber_number = function (codeword) {\n        return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));\n    };\n    PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array = function (moduleBitCount) {\n        return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;\n    };\n    PDF417ScanningDecoder.toString = function (barcodeMatrix) {\n        var formatter = new Formatter_1.default();\n        // try (let formatter = new Formatter()) {\n        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n            formatter.format('Row %2d: ', row);\n            for (var column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {\n                var barcodeValue = barcodeMatrix[row][column];\n                if (barcodeValue.getValue().length === 0) {\n                    formatter.format('        ', null);\n                }\n                else {\n                    formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));\n                }\n            }\n            formatter.format('%n');\n        }\n        return formatter.toString();\n        // }\n    };\n    /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;\n    /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;\n    /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;\n    /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection_1.default();\n    return PDF417ScanningDecoder;\n}());\nexports.default = PDF417ScanningDecoder;\n//# sourceMappingURL=PDF417ScanningDecoder.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","Object","defineProperty","ChecksumException_1","FormatException_1","NotFoundException_1","MathUtils_1","PDF417Common_1","ErrorCorrection_1","BoundingBox_1","DetectionResultRowIndicatorColumn_1","DetectionResult_1","DetectionResultColumn_1","Codeword_1","BarcodeValue_1","PDF417CodewordDecoder_1","DecodedBitStreamParser_1","Formatter_1","PDF417ScanningDecoder","decode","PDF417ScanningDecoder.decode","image","imageTopLeft","imageBottomLeft","imageTopRight","imageBottomRight","minCodewordWidth","maxCodewordWidth","boundingBox","default","leftRowIndicatorColumn","rightRowIndicatorColumn","firstPass","getRowIndicatorColumn","detectionResult","merge","getNotFoundInstance","resultBox","getBoundingBox","getMinY","getMaxY","setBoundingBox","maxBarcodeColumn","getBarcodeColumnCount","setDetectionResultColumn","leftToRight","barcodeColumnCount","barcodeColumn","undefined","getDetectionResultColumn","detectionResultColumn","previousStartColumn","startColumn","imageRow","getStartColumn","getMaxX","codeword","detectCodeword","getMinX","setCodeword","Math","min","getWidth","max","createDecoderResult","PDF417ScanningDecoder.merge","barcodeMetadata","getBarcodeMetadata","adjustBoundingBox","PDF417ScanningDecoder.adjustBoundingBox","rowIndicatorColumn","_a","rowHeights","getRowHeights","maxRowHeight","getMax","missingStartRows","rowHeights_1","rowHeights_1_1","rowHeight","e_1_1","e_1","error","return","codewords","getCodewords","row","missingEndRows","addMissingRows","isLeft","PDF417ScanningDecoder.getMax","values","maxValue","values_1","values_1_1","e_2_1","e_2","PDF417ScanningDecoder.getBarcodeMetadata","leftBarcodeMetadata","rightBarcodeMetadata","getColumnCount","getErrorCorrectionLevel","getRowCount","PDF417ScanningDecoder.getRowIndicatorColumn","startPoint","increment","trunc","getX","getY","getStartX","getEndX","adjustCodewordCount","PDF417ScanningDecoder.adjustCodewordCount","barcodeMatrix","barcodeMatrix01","numberOfCodewords","getValue","calculatedNumberOfCodewords","getBarcodeRowCount","getNumberOfECCodeWords","getBarcodeECLevel","MAX_CODEWORDS_IN_BARCODE","setValue","PDF417ScanningDecoder.createDecoderResult","createBarcodeMatrix","erasures","Int32Array","ambiguousIndexValuesList","ambiguousIndexesList","column","codewordIndex","push","ambiguousIndexValues","Array","createDecoderResultFromAmbiguousValues","toIntArray","PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues","ecLevel","erasureArray","ambiguousIndexes","ambiguousIndexCount","tries","decodeCodewords","err","getChecksumInstance","PDF417ScanningDecoder.createBarcodeMatrix","e_3","e_4","_b","from","column_1","_c","getDetectionResultColumns","_d","_e","_f","rowNumber","getRowNumber","e_4_1","e_3_1","isValidBarcodeColumn","PDF417ScanningDecoder.isValidBarcodeColumn","PDF417ScanningDecoder.getStartColumn","e_5","offset","getCodeword","getCodewordNearby","skippedColumns","previousRowCodeword","e_5_1","PDF417ScanningDecoder.detectCodeword","minColumn","maxColumn","adjustCodewordStartColumn","moduleBitCount","getModuleBitCount","codewordBitCount","sum","endColumn","tmpCount","checkCodewordSkew","decodedValue","getDecodedValue","getCodewordBucketNumber","PDF417ScanningDecoder.getModuleBitCount","moduleNumber","previousPixelValue","imageColumn","get","PDF417ScanningDecoder.getNumberOfECCodeWords","barcodeECLevel","PDF417ScanningDecoder.adjustCodewordStartColumn","codewordStartColumn","correctedStartColumn","abs","CODEWORD_SKEW_SIZE","PDF417ScanningDecoder.checkCodewordSkew","codewordSize","PDF417ScanningDecoder.decodeCodewords","getFormatInstance","numECCodewords","correctedErrorsCount","correctErrors","verifyCodewordCount","decoderResult","setErrorsCorrected","setErasures","PDF417ScanningDecoder.correctErrors","MAX_ERRORS","MAX_EC_CODEWORDS","errorCorrection","PDF417ScanningDecoder.verifyCodewordCount","getBitCountForCodeword","PDF417ScanningDecoder.getBitCountForCodeword","result","previousValue","PDF417ScanningDecoder.getCodewordBucketNumber","getCodewordBucketNumber_Int32Array","getCodewordBucketNumber_number","PDF417ScanningDecoder.getCodewordBucketNumber_number","PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array","toString","PDF417ScanningDecoder.toString","formatter","format","barcodeValue","getConfidence"]
}
