{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$BitMatrixParser.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/decoder/BitMatrixParser.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$decoder$BitMatrixParser\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Version_1 = require(\"./Version\");\nvar FormatInformation_1 = require(\"./FormatInformation\");\nvar DataMask_1 = require(\"./DataMask\");\nvar FormatException_1 = require(\"../../FormatException\");\n/**\n * @author Sean Owen\n */\nvar BitMatrixParser = /** @class */ (function () {\n    /**\n     * @param bitMatrix {@link BitMatrix} to parse\n     * @throws FormatException if dimension is not >= 21 and 1 mod 4\n     */\n    function BitMatrixParser(bitMatrix) {\n        var dimension = bitMatrix.getHeight();\n        if (dimension < 21 || (dimension & 0x03) !== 1) {\n            throw new FormatException_1.default();\n        }\n        this.bitMatrix = bitMatrix;\n    }\n    /**\n     * <p>Reads format information from one of its two locations within the QR Code.</p>\n     *\n     * @return {@link FormatInformation} encapsulating the QR Code's format info\n     * @throws FormatException if both format information locations cannot be parsed as\n     * the valid encoding of format information\n     */\n    BitMatrixParser.prototype.readFormatInformation = function () {\n        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n            return this.parsedFormatInfo;\n        }\n        // Read top-left format info bits\n        var formatInfoBits1 = 0;\n        for (var i = 0; i < 6; i++) {\n            formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n        }\n        // .. and skip a bit in the timing pattern ...\n        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n        // .. and skip a bit in the timing pattern ...\n        for (var j = 5; j >= 0; j--) {\n            formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n        }\n        // Read the top-right/bottom-left pattern too\n        var dimension = this.bitMatrix.getHeight();\n        var formatInfoBits2 = 0;\n        var jMin = dimension - 7;\n        for (var j = dimension - 1; j >= jMin; j--) {\n            formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n        }\n        for (var i = dimension - 8; i < dimension; i++) {\n            formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n        }\n        this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n        if (this.parsedFormatInfo !== null) {\n            return this.parsedFormatInfo;\n        }\n        throw new FormatException_1.default();\n    };\n    /**\n     * <p>Reads version information from one of its two locations within the QR Code.</p>\n     *\n     * @return {@link Version} encapsulating the QR Code's version\n     * @throws FormatException if both version information locations cannot be parsed as\n     * the valid encoding of version information\n     */\n    BitMatrixParser.prototype.readVersion = function () {\n        if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n            return this.parsedVersion;\n        }\n        var dimension = this.bitMatrix.getHeight();\n        var provisionalVersion = Math.floor((dimension - 17) / 4);\n        if (provisionalVersion <= 6) {\n            return Version_1.default.getVersionForNumber(provisionalVersion);\n        }\n        // Read top-right version info: 3 wide by 6 tall\n        var versionBits = 0;\n        var ijMin = dimension - 11;\n        for (var j = 5; j >= 0; j--) {\n            for (var i = dimension - 9; i >= ijMin; i--) {\n                versionBits = this.copyBit(i, j, versionBits);\n            }\n        }\n        var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n            this.parsedVersion = theParsedVersion;\n            return theParsedVersion;\n        }\n        // Hmm, failed. Try bottom left: 6 wide by 3 tall\n        versionBits = 0;\n        for (var i = 5; i >= 0; i--) {\n            for (var j = dimension - 9; j >= ijMin; j--) {\n                versionBits = this.copyBit(i, j, versionBits);\n            }\n        }\n        theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n            this.parsedVersion = theParsedVersion;\n            return theParsedVersion;\n        }\n        throw new FormatException_1.default();\n    };\n    BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {\n        var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n        return bit ? (versionBits << 1) | 0x1 : versionBits << 1;\n    };\n    /**\n     * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n     * correct order in order to reconstruct the codewords bytes contained within the\n     * QR Code.</p>\n     *\n     * @return bytes encoded within the QR Code\n     * @throws FormatException if the exact number of bytes expected is not read\n     */\n    BitMatrixParser.prototype.readCodewords = function () {\n        var formatInfo = this.readFormatInformation();\n        var version = this.readVersion();\n        // Get the data mask for the format used in this QR Code. This will exclude\n        // some bits from reading as we wind through the bit matrix.\n        var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());\n        var dimension = this.bitMatrix.getHeight();\n        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n        var functionPattern = version.buildFunctionPattern();\n        var readingUp = true;\n        var result = new Uint8Array(version.getTotalCodewords());\n        var resultOffset = 0;\n        var currentByte = 0;\n        var bitsRead = 0;\n        // Read columns in pairs, from right to left\n        for (var j = dimension - 1; j > 0; j -= 2) {\n            if (j === 6) {\n                // Skip whole column with vertical alignment pattern\n                // saves time and makes the other code proceed more cleanly\n                j--;\n            }\n            // Read alternatingly from bottom to top then top to bottom\n            for (var count = 0; count < dimension; count++) {\n                var i = readingUp ? dimension - 1 - count : count;\n                for (var col = 0; col < 2; col++) {\n                    // Ignore bits covered by the function pattern\n                    if (!functionPattern.get(j - col, i)) {\n                        // Read a bit\n                        bitsRead++;\n                        currentByte <<= 1;\n                        if (this.bitMatrix.get(j - col, i)) {\n                            currentByte |= 1;\n                        }\n                        // If we've made a whole byte, save it off\n                        if (bitsRead === 8) {\n                            result[resultOffset++] = /*(byte) */ currentByte;\n                            bitsRead = 0;\n                            currentByte = 0;\n                        }\n                    }\n                }\n            }\n            readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n        }\n        if (resultOffset !== version.getTotalCodewords()) {\n            throw new FormatException_1.default();\n        }\n        return result;\n    };\n    /**\n     * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n     */\n    BitMatrixParser.prototype.remask = function () {\n        if (this.parsedFormatInfo === null) {\n            return; // We have no format information, and have no data mask\n        }\n        var dataMask = DataMask_1.default.values[this.parsedFormatInfo.getDataMask()];\n        var dimension = this.bitMatrix.getHeight();\n        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n    };\n    /**\n     * Prepare the parser for a mirrored operation.\n     * This flag has effect only on the {@link #readFormatInformation()} and the\n     * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n     * {@link #mirror()} method should be called.\n     *\n     * @param mirror Whether to read version and format information mirrored.\n     */\n    BitMatrixParser.prototype.setMirror = function (isMirror) {\n        this.parsedVersion = null;\n        this.parsedFormatInfo = null;\n        this.isMirror = isMirror;\n    };\n    /** Mirror the bit matrix in order to attempt a second reading. */\n    BitMatrixParser.prototype.mirror = function () {\n        var bitMatrix = this.bitMatrix;\n        for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n            for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n                if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n                    bitMatrix.flip(y, x);\n                    bitMatrix.flip(x, y);\n                }\n            }\n        }\n    };\n    return BitMatrixParser;\n}());\nexports.default = BitMatrixParser;\n//# sourceMappingURL=BitMatrixParser.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","Version_1","FormatInformation_1","DataMask_1","FormatException_1","BitMatrixParser","bitMatrix","dimension","getHeight","default","prototype","readFormatInformation","BitMatrixParser.prototype.readFormatInformation","parsedFormatInfo","undefined","formatInfoBits1","i","copyBit","j","formatInfoBits2","jMin","decodeFormatInformation","readVersion","BitMatrixParser.prototype.readVersion","parsedVersion","provisionalVersion","Math","floor","getVersionForNumber","versionBits","ijMin","theParsedVersion","decodeVersionInformation","getDimensionForVersion","BitMatrixParser.prototype.copyBit","isMirror","bit","get","readCodewords","BitMatrixParser.prototype.readCodewords","formatInfo","version","dataMask","values","getDataMask","unmaskBitMatrix","functionPattern","buildFunctionPattern","readingUp","result","Uint8Array","getTotalCodewords","resultOffset","currentByte","bitsRead","count","col","remask","BitMatrixParser.prototype.remask","setMirror","BitMatrixParser.prototype.setMirror","mirror","BitMatrixParser.prototype.mirror","x","width","getWidth","y","height","flip"]
}
