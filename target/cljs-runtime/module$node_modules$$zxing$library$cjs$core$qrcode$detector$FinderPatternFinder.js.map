{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$qrcode$detector$FinderPatternFinder.js",
"lineCount":24,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/qrcode/detector/FinderPatternFinder.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$qrcode$detector$FinderPatternFinder\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode.detector {*/\nvar DecodeHintType_1 = require(\"../../DecodeHintType\");\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar FinderPattern_1 = require(\"./FinderPattern\");\nvar FinderPatternInfo_1 = require(\"./FinderPatternInfo\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*import java.io.Serializable;*/\n/*import java.util.ArrayList;*/\n/*import java.util.Collections;*/\n/*import java.util.Comparator;*/\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square\n * markers at three corners of a QR Code.</p>\n *\n * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.\n *\n * @author Sean Owen\n */\nvar FinderPatternFinder = /** @class */ (function () {\n    /**\n     * <p>Creates a finder that will search the image for three finder patterns.</p>\n     *\n     * @param image image to search\n     */\n    // public constructor(image: BitMatrix) {\n    //   this(image, null)\n    // }\n    function FinderPatternFinder(image, resultPointCallback) {\n        this.image = image;\n        this.resultPointCallback = resultPointCallback;\n        this.possibleCenters = [];\n        this.crossCheckStateCount = new Int32Array(5);\n        this.resultPointCallback = resultPointCallback;\n    }\n    FinderPatternFinder.prototype.getImage = function () {\n        return this.image;\n    };\n    FinderPatternFinder.prototype.getPossibleCenters = function () {\n        return this.possibleCenters;\n    };\n    FinderPatternFinder.prototype.find = function (hints) {\n        var tryHarder = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1.default.TRY_HARDER);\n        var pureBarcode = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE);\n        var image = this.image;\n        var maxI = image.getHeight();\n        var maxJ = image.getWidth();\n        // We are looking for black/white/black/white/black modules in\n        // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far\n        // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the\n        // image, and then account for the center being 3 modules in size. This gives the smallest\n        // number of pixels the center could be, so skip this often. When trying harder, look for all\n        // QR versions regardless of how dense they are.\n        var iSkip = Math.floor((3 * maxI) / (4 * FinderPatternFinder.MAX_MODULES));\n        if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {\n            iSkip = FinderPatternFinder.MIN_SKIP;\n        }\n        var done = false;\n        var stateCount = new Int32Array(5);\n        for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {\n            // Get a row of black/white values\n            stateCount[0] = 0;\n            stateCount[1] = 0;\n            stateCount[2] = 0;\n            stateCount[3] = 0;\n            stateCount[4] = 0;\n            var currentState = 0;\n            for (var j = 0; j < maxJ; j++) {\n                if (image.get(j, i)) {\n                    // Black pixel\n                    if ((currentState & 1) === 1) { // Counting white pixels\n                        currentState++;\n                    }\n                    stateCount[currentState]++;\n                }\n                else { // White pixel\n                    if ((currentState & 1) === 0) { // Counting black pixels\n                        if (currentState === 4) { // A winner?\n                            if (FinderPatternFinder.foundPatternCross(stateCount)) { // Yes\n                                var confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);\n                                if (confirmed === true) {\n                                    // Start examining every other line. Checking each line turned out to be too\n                                    // expensive and didn't improve performance.\n                                    iSkip = 2;\n                                    if (this.hasSkipped === true) {\n                                        done = this.haveMultiplyConfirmedCenters();\n                                    }\n                                    else {\n                                        var rowSkip = this.findRowSkip();\n                                        if (rowSkip > stateCount[2]) {\n                                            // Skip rows between row of lower confirmed center\n                                            // and top of presumed third confirmed center\n                                            // but back up a bit to get a full chance of detecting\n                                            // it, entire width of center of finder pattern\n                                            // Skip by rowSkip, but back off by stateCount[2] (size of last center\n                                            // of pattern we saw) to be conservative, and also back off by iSkip which\n                                            // is about to be re-added\n                                            i += rowSkip - stateCount[2] - iSkip;\n                                            j = maxJ - 1;\n                                        }\n                                    }\n                                }\n                                else {\n                                    stateCount[0] = stateCount[2];\n                                    stateCount[1] = stateCount[3];\n                                    stateCount[2] = stateCount[4];\n                                    stateCount[3] = 1;\n                                    stateCount[4] = 0;\n                                    currentState = 3;\n                                    continue;\n                                }\n                                // Clear state to start looking again\n                                currentState = 0;\n                                stateCount[0] = 0;\n                                stateCount[1] = 0;\n                                stateCount[2] = 0;\n                                stateCount[3] = 0;\n                                stateCount[4] = 0;\n                            }\n                            else { // No, shift counts back by two\n                                stateCount[0] = stateCount[2];\n                                stateCount[1] = stateCount[3];\n                                stateCount[2] = stateCount[4];\n                                stateCount[3] = 1;\n                                stateCount[4] = 0;\n                                currentState = 3;\n                            }\n                        }\n                        else {\n                            stateCount[++currentState]++;\n                        }\n                    }\n                    else { // Counting white pixels\n                        stateCount[currentState]++;\n                    }\n                }\n            }\n            if (FinderPatternFinder.foundPatternCross(stateCount)) {\n                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);\n                if (confirmed === true) {\n                    iSkip = stateCount[0];\n                    if (this.hasSkipped) {\n                        // Found a third one\n                        done = this.haveMultiplyConfirmedCenters();\n                    }\n                }\n            }\n        }\n        var patternInfo = this.selectBestPatterns();\n        ResultPoint_1.default.orderBestPatterns(patternInfo);\n        return new FinderPatternInfo_1.default(patternInfo);\n    };\n    /**\n     * Given a count of black/white/black/white/black pixels just seen and an end position,\n     * figures the location of the center of this run.\n     */\n    FinderPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {\n        return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;\n    };\n    /**\n     * @param stateCount count of black/white/black/white/black pixels just read\n     * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios\n     *         used by finder patterns to be considered a match\n     */\n    FinderPatternFinder.foundPatternCross = function (stateCount) {\n        var totalModuleSize = 0;\n        for (var i = 0; i < 5; i++) {\n            var count = stateCount[i];\n            if (count === 0) {\n                return false;\n            }\n            totalModuleSize += count;\n        }\n        if (totalModuleSize < 7) {\n            return false;\n        }\n        var moduleSize = totalModuleSize / 7.0;\n        var maxVariance = moduleSize / 2.0;\n        // Allow less than 50% variance from 1-1-3-1-1 proportions\n        return Math.abs(moduleSize - stateCount[0]) < maxVariance &&\n            Math.abs(moduleSize - stateCount[1]) < maxVariance &&\n            Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&\n            Math.abs(moduleSize - stateCount[3]) < maxVariance &&\n            Math.abs(moduleSize - stateCount[4]) < maxVariance;\n    };\n    FinderPatternFinder.prototype.getCrossCheckStateCount = function () {\n        var crossCheckStateCount = this.crossCheckStateCount;\n        crossCheckStateCount[0] = 0;\n        crossCheckStateCount[1] = 0;\n        crossCheckStateCount[2] = 0;\n        crossCheckStateCount[3] = 0;\n        crossCheckStateCount[4] = 0;\n        return crossCheckStateCount;\n    };\n    /**\n     * After a vertical and horizontal scan finds a potential finder pattern, this method\n     * \"cross-cross-cross-checks\" by scanning down diagonally through the center of the possible\n     * finder pattern to see if the same proportion is detected.\n     *\n     * @param startI row where a finder pattern was detected\n     * @param centerJ center of the section that appears to cross a finder pattern\n     * @param maxCount maximum reasonable number of modules that should be\n     *  observed in any reading state, based on the results of the horizontal scan\n     * @param originalStateCountTotal The original state count total.\n     * @return true if proportions are withing expected limits\n     */\n    FinderPatternFinder.prototype.crossCheckDiagonal = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n        var stateCount = this.getCrossCheckStateCount();\n        // Start counting up, left from center finding black center mass\n        var i = 0;\n        var image = this.image;\n        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {\n            stateCount[2]++;\n            i++;\n        }\n        if (startI < i || centerJ < i) {\n            return false;\n        }\n        // Continue up, left finding white space\n        while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&\n            stateCount[1] <= maxCount) {\n            stateCount[1]++;\n            i++;\n        }\n        // If already too many modules in this state or ran off the edge:\n        if (startI < i || centerJ < i || stateCount[1] > maxCount) {\n            return false;\n        }\n        // Continue up, left finding black border\n        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&\n            stateCount[0] <= maxCount) {\n            stateCount[0]++;\n            i++;\n        }\n        if (stateCount[0] > maxCount) {\n            return false;\n        }\n        var maxI = image.getHeight();\n        var maxJ = image.getWidth();\n        // Now also count down, right from center\n        i = 1;\n        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {\n            stateCount[2]++;\n            i++;\n        }\n        // Ran off the edge?\n        if (startI + i >= maxI || centerJ + i >= maxJ) {\n            return false;\n        }\n        while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&\n            stateCount[3] < maxCount) {\n            stateCount[3]++;\n            i++;\n        }\n        if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {\n            return false;\n        }\n        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&\n            stateCount[4] < maxCount) {\n            stateCount[4]++;\n            i++;\n        }\n        if (stateCount[4] >= maxCount) {\n            return false;\n        }\n        // If we found a finder-pattern-like section, but its size is more than 100% different than\n        // the original, assume it's a false positive\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&\n            FinderPatternFinder.foundPatternCross(stateCount);\n    };\n    /**\n     * <p>After a horizontal scan finds a potential finder pattern, this method\n     * \"cross-checks\" by scanning down vertically through the center of the possible\n     * finder pattern to see if the same proportion is detected.</p>\n     *\n     * @param startI row where a finder pattern was detected\n     * @param centerJ center of the section that appears to cross a finder pattern\n     * @param maxCount maximum reasonable number of modules that should be\n     * observed in any reading state, based on the results of the horizontal scan\n     * @return vertical center of finder pattern, or {@link Float#NaN} if not found\n     */\n    FinderPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n        var image = this.image;\n        var maxI = image.getHeight();\n        var stateCount = this.getCrossCheckStateCount();\n        // Start counting up from center\n        var i = startI;\n        while (i >= 0 && image.get(centerJ, i)) {\n            stateCount[2]++;\n            i--;\n        }\n        if (i < 0) {\n            return NaN;\n        }\n        while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {\n            stateCount[1]++;\n            i--;\n        }\n        // If already too many modules in this state or ran off the edge:\n        if (i < 0 || stateCount[1] > maxCount) {\n            return NaN;\n        }\n        while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {\n            stateCount[0]++;\n            i--;\n        }\n        if (stateCount[0] > maxCount) {\n            return NaN;\n        }\n        // Now also count down from center\n        i = startI + 1;\n        while (i < maxI && image.get(centerJ, i)) {\n            stateCount[2]++;\n            i++;\n        }\n        if (i === maxI) {\n            return NaN;\n        }\n        while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {\n            stateCount[3]++;\n            i++;\n        }\n        if (i === maxI || stateCount[3] >= maxCount) {\n            return NaN;\n        }\n        while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {\n            stateCount[4]++;\n            i++;\n        }\n        if (stateCount[4] >= maxCount) {\n            return NaN;\n        }\n        // If we found a finder-pattern-like section, but its size is more than 40% different than\n        // the original, assume it's a false positive\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n            stateCount[4];\n        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n            return NaN;\n        }\n        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;\n    };\n    /**\n     * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,\n     * except it reads horizontally instead of vertically. This is used to cross-cross\n     * check a vertical cross check and locate the real center of the alignment pattern.</p>\n     */\n    FinderPatternFinder.prototype.crossCheckHorizontal = function (startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n        var image = this.image;\n        var maxJ = image.getWidth();\n        var stateCount = this.getCrossCheckStateCount();\n        var j = startJ;\n        while (j >= 0 && image.get(j, centerI)) {\n            stateCount[2]++;\n            j--;\n        }\n        if (j < 0) {\n            return NaN;\n        }\n        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {\n            stateCount[1]++;\n            j--;\n        }\n        if (j < 0 || stateCount[1] > maxCount) {\n            return NaN;\n        }\n        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {\n            stateCount[0]++;\n            j--;\n        }\n        if (stateCount[0] > maxCount) {\n            return NaN;\n        }\n        j = startJ + 1;\n        while (j < maxJ && image.get(j, centerI)) {\n            stateCount[2]++;\n            j++;\n        }\n        if (j === maxJ) {\n            return NaN;\n        }\n        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {\n            stateCount[3]++;\n            j++;\n        }\n        if (j === maxJ || stateCount[3] >= maxCount) {\n            return NaN;\n        }\n        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {\n            stateCount[4]++;\n            j++;\n        }\n        if (stateCount[4] >= maxCount) {\n            return NaN;\n        }\n        // If we found a finder-pattern-like section, but its size is significantly different than\n        // the original, assume it's a false positive\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n            stateCount[4];\n        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n            return NaN;\n        }\n        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;\n    };\n    /**\n     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n     * cross check with a vertical scan, and if successful, will, ah, cross-cross-check\n     * with another horizontal scan. This is needed primarily to locate the real horizontal\n     * center of the pattern in cases of extreme skew.\n     * And then we cross-cross-cross check with another diagonal scan.</p>\n     *\n     * <p>If that succeeds the finder pattern location is added to a list that tracks\n     * the number of times each location has been nearly-matched as a finder pattern.\n     * Each additional find is more evidence that the location is in fact a finder\n     * pattern center\n     *\n     * @param stateCount reading state module counts from horizontal scan\n     * @param i row where finder pattern may be found\n     * @param j end of possible finder pattern in row\n     * @param pureBarcode true if in \"pure barcode\" mode\n     * @return true if a finder pattern candidate was found this time\n     */\n    FinderPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/, pureBarcode) {\n        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n            stateCount[4];\n        var centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);\n        var centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);\n        if (!isNaN(centerI)) {\n            // Re-cross check\n            centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);\n            if (!isNaN(centerJ) &&\n                (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {\n                var estimatedModuleSize = stateCountTotal / 7.0;\n                var found = false;\n                var possibleCenters = this.possibleCenters;\n                for (var index = 0, length_1 = possibleCenters.length; index < length_1; index++) {\n                    var center = possibleCenters[index];\n                    // Look for about the same center and module size:\n                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                        possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    var point = new FinderPattern_1.default(centerJ, centerI, estimatedModuleSize);\n                    possibleCenters.push(point);\n                    if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n                        this.resultPointCallback.foundPossibleResultPoint(point);\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return number of rows we could safely skip during scanning, based on the first\n     *         two finder patterns that have been located. In some cases their position will\n     *         allow us to infer that the third pattern must lie below a certain point farther\n     *         down in the image.\n     */\n    FinderPatternFinder.prototype.findRowSkip = function () {\n        var e_1, _a;\n        var max = this.possibleCenters.length;\n        if (max <= 1) {\n            return 0;\n        }\n        var firstConfirmedCenter = null;\n        try {\n            for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var center = _c.value;\n                if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    if (firstConfirmedCenter == null) {\n                        firstConfirmedCenter = center;\n                    }\n                    else {\n                        // We have two confirmed centers\n                        // How far down can we skip before resuming looking for the next\n                        // pattern? In the worst case, only the difference between the\n                        // difference in the x / y coordinates of the two centers.\n                        // This is the case where you find top left last.\n                        this.hasSkipped = true;\n                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -\n                            Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return 0;\n    };\n    /**\n     * @return true iff we have found at least 3 finder patterns that have been detected\n     *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the\n     *         candidates is \"pretty similar\"\n     */\n    FinderPatternFinder.prototype.haveMultiplyConfirmedCenters = function () {\n        var e_2, _a, e_3, _b;\n        var confirmedCount = 0;\n        var totalModuleSize = 0.0;\n        var max = this.possibleCenters.length;\n        try {\n            for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var pattern = _d.value;\n                if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    confirmedCount++;\n                    totalModuleSize += pattern.getEstimatedModuleSize();\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        if (confirmedCount < 3) {\n            return false;\n        }\n        // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\n        // and that we need to keep looking. We detect this by asking if the estimated module sizes\n        // vary too much. We arbitrarily say that when the total deviation from average exceeds\n        // 5% of the total module size estimates, it's too much.\n        var average = totalModuleSize / max;\n        var totalDeviation = 0.0;\n        try {\n            for (var _e = __values(this.possibleCenters), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var pattern = _f.value;\n                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return totalDeviation <= 0.05 * totalModuleSize;\n    };\n    /**\n     * @return the 3 best {@link FinderPattern}s from our list of candidates. The \"best\" are\n     *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module\n     *         size differs from the average among those patterns the least\n     * @throws NotFoundException if 3 such finder patterns do not exist\n     */\n    FinderPatternFinder.prototype.selectBestPatterns = function () {\n        var e_4, _a, e_5, _b;\n        var startSize = this.possibleCenters.length;\n        if (startSize < 3) {\n            // Couldn't find enough finder patterns\n            throw new NotFoundException_1.default();\n        }\n        var possibleCenters = this.possibleCenters;\n        var average;\n        // Filter outlier possibilities whose module size is too different\n        if (startSize > 3) {\n            // But we can only afford to do so if we have at least 4 possibilities to choose from\n            var totalModuleSize = 0.0;\n            var square = 0.0;\n            try {\n                for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var center = _d.value;\n                    var size = center.getEstimatedModuleSize();\n                    totalModuleSize += size;\n                    square += size * size;\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n            average = totalModuleSize / startSize;\n            var stdDev = Math.sqrt(square / startSize - average * average);\n            possibleCenters.sort(\n            /**\n             * <p>Orders by furthest from average</p>\n             */\n            // FurthestFromAverageComparator implements Comparator<FinderPattern>\n            function (center1, center2) {\n                var dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                var dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                return dA < dB ? -1 : dA > dB ? 1 : 0;\n            });\n            var limit = Math.max(0.2 * average, stdDev);\n            for (var i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {\n                var pattern = possibleCenters[i];\n                if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {\n                    possibleCenters.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        if (possibleCenters.length > 3) {\n            // Throw away all but those first size candidate points we found.\n            var totalModuleSize = 0.0;\n            try {\n                for (var possibleCenters_1 = __values(possibleCenters), possibleCenters_1_1 = possibleCenters_1.next(); !possibleCenters_1_1.done; possibleCenters_1_1 = possibleCenters_1.next()) {\n                    var possibleCenter = possibleCenters_1_1.value;\n                    totalModuleSize += possibleCenter.getEstimatedModuleSize();\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (possibleCenters_1_1 && !possibleCenters_1_1.done && (_b = possibleCenters_1.return)) _b.call(possibleCenters_1);\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n            average = totalModuleSize / possibleCenters.length;\n            possibleCenters.sort(\n            /**\n             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>\n             */\n            // CenterComparator implements Comparator<FinderPattern>\n            function (center1, center2) {\n                if (center2.getCount() === center1.getCount()) {\n                    var dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                    var dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                    return dA < dB ? 1 : dA > dB ? -1 : 0;\n                }\n                else {\n                    return center2.getCount() - center1.getCount();\n                }\n            });\n            possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway\n        }\n        return [\n            possibleCenters[0],\n            possibleCenters[1],\n            possibleCenters[2]\n        ];\n    };\n    FinderPatternFinder.CENTER_QUORUM = 2;\n    FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center\n    FinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients\n    return FinderPatternFinder;\n}());\nexports.default = FinderPatternFinder;\n//# sourceMappingURL=FinderPatternFinder.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","Object","defineProperty","DecodeHintType_1","ResultPoint_1","FinderPattern_1","FinderPatternInfo_1","NotFoundException_1","FinderPatternFinder","image","resultPointCallback","possibleCenters","crossCheckStateCount","Int32Array","prototype","getImage","FinderPatternFinder.prototype.getImage","getPossibleCenters","FinderPatternFinder.prototype.getPossibleCenters","find","FinderPatternFinder.prototype.find","hints","tryHarder","undefined","get","default","TRY_HARDER","pureBarcode","PURE_BARCODE","maxI","getHeight","maxJ","getWidth","iSkip","Math","floor","MAX_MODULES","MIN_SKIP","stateCount","currentState","j","foundPatternCross","confirmed","handlePossibleCenter","hasSkipped","haveMultiplyConfirmedCenters","rowSkip","findRowSkip","patternInfo","selectBestPatterns","orderBestPatterns","centerFromEnd","FinderPatternFinder.centerFromEnd","end","FinderPatternFinder.foundPatternCross","totalModuleSize","count","moduleSize","maxVariance","abs","getCrossCheckStateCount","FinderPatternFinder.prototype.getCrossCheckStateCount","crossCheckDiagonal","FinderPatternFinder.prototype.crossCheckDiagonal","startI","centerJ","maxCount","originalStateCountTotal","crossCheckVertical","FinderPatternFinder.prototype.crossCheckVertical","NaN","crossCheckHorizontal","FinderPatternFinder.prototype.crossCheckHorizontal","startJ","centerI","FinderPatternFinder.prototype.handlePossibleCenter","stateCountTotal","isNaN","estimatedModuleSize","found","index","length_1","center","aboutEquals","combineEstimate","point","push","foundPossibleResultPoint","FinderPatternFinder.prototype.findRowSkip","_a","firstConfirmedCenter","_b","_c","getCount","CENTER_QUORUM","getX","getY","e_1_1","e_1","error","return","FinderPatternFinder.prototype.haveMultiplyConfirmedCenters","confirmedCount","max","_d","pattern","getEstimatedModuleSize","e_2_1","e_2","average","totalDeviation","_e","_f","e_3_1","e_3","FinderPatternFinder.prototype.selectBestPatterns","startSize","square","size","e_4_1","e_4","stdDev","sqrt","sort","center1","center2","dA","dB","limit","splice","possibleCenters_1","possibleCenters_1_1","e_5_1","e_5"]
}
