{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$datamatrix$DataMatrixReader.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/datamatrix/DataMatrixReader.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$datamatrix$DataMatrixReader\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar BitMatrix_1 = require(\"../common/BitMatrix\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar Result_1 = require(\"../Result\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar System_1 = require(\"../util/System\");\nvar Decoder_1 = require(\"./decoder/Decoder\");\nvar Detector_1 = require(\"./detector/Detector\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This implementation can detect and decode Data Matrix codes in an image.\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar DataMatrixReader = /** @class */ (function () {\n    function DataMatrixReader() {\n        this.decoder = new Decoder_1.default();\n    }\n    /**\n     * Locates and decodes a Data Matrix code in an image.\n     *\n     * @return a String representing the content encoded by the Data Matrix code\n     * @throws NotFoundException if a Data Matrix code cannot be found\n     * @throws FormatException if a Data Matrix code cannot be decoded\n     * @throws ChecksumException if error correction fails\n     */\n    // @Override\n    // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n    //   return decode(image, null);\n    // }\n    // @Override\n    DataMatrixReader.prototype.decode = function (image, hints) {\n        if (hints === void 0) { hints = null; }\n        var decoderResult;\n        var points;\n        if (hints != null && hints.has(DecodeHintType_1.default.PURE_BARCODE)) {\n            var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n            decoderResult = this.decoder.decode(bits);\n            points = DataMatrixReader.NO_POINTS;\n        }\n        else {\n            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect();\n            decoderResult = this.decoder.decode(detectorResult.getBits());\n            points = detectorResult.getPoints();\n        }\n        var rawBytes = decoderResult.getRawBytes();\n        var result = new Result_1.default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_1.default.DATA_MATRIX, System_1.default.currentTimeMillis());\n        var byteSegments = decoderResult.getByteSegments();\n        if (byteSegments != null) {\n            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);\n        }\n        var ecLevel = decoderResult.getECLevel();\n        if (ecLevel != null) {\n            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);\n        }\n        return result;\n    };\n    // @Override\n    DataMatrixReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n     * which contains only an unrotated, unskewed, image of a code, with some white border\n     * around it. This is a specialized method that works exceptionally fast in this special\n     * case.\n     *\n     * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n     */\n    DataMatrixReader.extractPureBits = function (image) {\n        var leftTopBlack = image.getTopLeftOnBit();\n        var rightBottomBlack = image.getBottomRightOnBit();\n        if (leftTopBlack == null || rightBottomBlack == null) {\n            throw new NotFoundException_1.default();\n        }\n        var moduleSize = this.moduleSize(leftTopBlack, image);\n        var top = leftTopBlack[1];\n        var bottom = rightBottomBlack[1];\n        var left = leftTopBlack[0];\n        var right = rightBottomBlack[0];\n        var matrixWidth = (right - left + 1) / moduleSize;\n        var matrixHeight = (bottom - top + 1) / moduleSize;\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\n            throw new NotFoundException_1.default();\n        }\n        // Push in the \"border\" by half the module width so that we start\n        // sampling in the middle of the module. Just in case the image is a\n        // little off, this will help recover.\n        var nudge = moduleSize / 2;\n        top += nudge;\n        left += nudge;\n        // Now just read off the bits\n        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);\n        for (var y = 0; y < matrixHeight; y++) {\n            var iOffset = top + y * moduleSize;\n            for (var x = 0; x < matrixWidth; x++) {\n                if (image.get(left + x * moduleSize, iOffset)) {\n                    bits.set(x, y);\n                }\n            }\n        }\n        return bits;\n    };\n    DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n        var width = image.getWidth();\n        var x = leftTopBlack[0];\n        var y = leftTopBlack[1];\n        while (x < width && image.get(x, y)) {\n            x++;\n        }\n        if (x === width) {\n            throw new NotFoundException_1.default();\n        }\n        var moduleSize = x - leftTopBlack[0];\n        if (moduleSize === 0) {\n            throw new NotFoundException_1.default();\n        }\n        return moduleSize;\n    };\n    DataMatrixReader.NO_POINTS = [];\n    return DataMatrixReader;\n}());\nexports.default = DataMatrixReader;\n//# sourceMappingURL=DataMatrixReader.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","BarcodeFormat_1","BitMatrix_1","DecodeHintType_1","NotFoundException_1","Result_1","ResultMetadataType_1","System_1","Decoder_1","Detector_1","DataMatrixReader","decoder","default","prototype","decode","DataMatrixReader.prototype.decode","image","hints","has","PURE_BARCODE","bits","extractPureBits","getBlackMatrix","decoderResult","points","NO_POINTS","detectorResult","detect","getBits","getPoints","rawBytes","getRawBytes","result","getText","length","DATA_MATRIX","currentTimeMillis","byteSegments","getByteSegments","putMetadata","BYTE_SEGMENTS","ecLevel","getECLevel","ERROR_CORRECTION_LEVEL","reset","DataMatrixReader.prototype.reset","DataMatrixReader.extractPureBits","leftTopBlack","getTopLeftOnBit","rightBottomBlack","getBottomRightOnBit","moduleSize","top","left","matrixWidth","right","matrixHeight","bottom","nudge","y","iOffset","x","get","set","DataMatrixReader.moduleSize","width","getWidth"]
}
