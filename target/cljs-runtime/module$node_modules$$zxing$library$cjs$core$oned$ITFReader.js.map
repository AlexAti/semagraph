{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$oned$ITFReader.js",
"lineCount":15,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/oned/ITFReader.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$oned$ITFReader\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.oned {*/\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar FormatException_1 = require(\"../FormatException\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar Result_1 = require(\"../Result\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\nvar StringBuilder_1 = require(\"../util/StringBuilder\");\nvar System_1 = require(\"../util/System\");\nvar OneDReader_1 = require(\"./OneDReader\");\n/**\n * <p>Decodes ITF barcodes.</p>\n *\n * @author Tjieco\n */\nvar ITFReader = /** @class */ (function (_super) {\n    __extends(ITFReader, _super);\n    function ITFReader() {\n        // private static W = 3; // Pixel width of a 3x wide line\n        // private static w = 2; // Pixel width of a 2x wide line\n        // private static N = 1; // Pixed width of a narrow line\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // Stores the actual narrow line width of the image being decoded.\n        _this.narrowLineWidth = -1;\n        return _this;\n    }\n    // See ITFWriter.PATTERNS\n    /*\n  \n    /!**\n     * Patterns of Wide / Narrow lines to indicate each digit\n     *!/\n    */\n    ITFReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var e_1, _a;\n        // Find out where the Middle section (payload) starts & ends\n        var startRange = this.decodeStart(row);\n        var endRange = this.decodeEnd(row);\n        var result = new StringBuilder_1.default();\n        ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);\n        var resultString = result.toString();\n        var allowedLengths = null;\n        if (hints != null) {\n            allowedLengths = hints.get(DecodeHintType_1.default.ALLOWED_LENGTHS);\n        }\n        if (allowedLengths == null) {\n            allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;\n        }\n        // To avoid false positives with 2D barcodes (and other patterns), make\n        // an assumption that the decoded string must be a 'standard' length if it's short\n        var length = resultString.length;\n        var lengthOK = false;\n        var maxAllowedLength = 0;\n        try {\n            for (var allowedLengths_1 = __values(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {\n                var value = allowedLengths_1_1.value;\n                if (length === value) {\n                    lengthOK = true;\n                    break;\n                }\n                if (value > maxAllowedLength) {\n                    maxAllowedLength = value;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a = allowedLengths_1.return)) _a.call(allowedLengths_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (!lengthOK && length > maxAllowedLength) {\n            lengthOK = true;\n        }\n        if (!lengthOK) {\n            throw new FormatException_1.default();\n        }\n        var points = [new ResultPoint_1.default(startRange[1], rowNumber), new ResultPoint_1.default(endRange[0], rowNumber)];\n        var resultReturn = new Result_1.default(resultString, null, // no natural byte representation for these barcodes\n        0, points, BarcodeFormat_1.default.ITF, new Date().getTime());\n        return resultReturn;\n    };\n    /*\n    /!**\n     * @param row          row of black/white values to search\n     * @param payloadStart offset of start pattern\n     * @param resultString {@link StringBuilder} to append decoded chars to\n     * @throws NotFoundException if decoding could not complete successfully\n     *!/*/\n    ITFReader.decodeMiddle = function (row, payloadStart, payloadEnd, resultString) {\n        // Digits are interleaved in pairs - 5 black lines for one digit, and the\n        // 5\n        // interleaved white lines for the second digit.\n        // Therefore, need to scan 10 lines and then\n        // split these into two arrays\n        var counterDigitPair = new Int32Array(10); // 10\n        var counterBlack = new Int32Array(5); // 5\n        var counterWhite = new Int32Array(5); // 5\n        counterDigitPair.fill(0);\n        counterBlack.fill(0);\n        counterWhite.fill(0);\n        while (payloadStart < payloadEnd) {\n            // Get 10 runs of black/white.\n            OneDReader_1.default.recordPattern(row, payloadStart, counterDigitPair);\n            // Split them into each array\n            for (var k = 0; k < 5; k++) {\n                var twoK = 2 * k;\n                counterBlack[k] = counterDigitPair[twoK];\n                counterWhite[k] = counterDigitPair[twoK + 1];\n            }\n            var bestMatch = ITFReader.decodeDigit(counterBlack);\n            resultString.append(bestMatch.toString());\n            bestMatch = this.decodeDigit(counterWhite);\n            resultString.append(bestMatch.toString());\n            counterDigitPair.forEach(function (counterDigit) {\n                payloadStart += counterDigit;\n            });\n        }\n    };\n    /*/!**\n     * Identify where the start of the middle / payload section starts.\n     *\n     * @param row row of black/white values to search\n     * @return Array, containing index of start of 'start block' and end of\n     *         'start block'\n     *!/*/\n    ITFReader.prototype.decodeStart = function (row) {\n        var endStart = ITFReader.skipWhiteSpace(row);\n        var startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);\n        // Determine the width of a narrow line in pixels. We can do this by\n        // getting the width of the start pattern and dividing by 4 because its\n        // made up of 4 narrow lines.\n        this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;\n        this.validateQuietZone(row, startPattern[0]);\n        return startPattern;\n    };\n    /*/!**\n     * The start & end patterns must be pre/post fixed by a quiet zone. This\n     * zone must be at least 10 times the width of a narrow line.  Scan back until\n     * we either get to the start of the barcode or match the necessary number of\n     * quiet zone pixels.\n     *\n     * Note: Its assumed the row is reversed when using this method to find\n     * quiet zone after the end pattern.\n     *\n     * ref: http://www.barcode-1.net/i25code.html\n     *\n     * @param row bit array representing the scanned barcode.\n     * @param startPattern index into row of the start or end pattern.\n     * @throws NotFoundException if the quiet zone cannot be found\n     *!/*/\n    ITFReader.prototype.validateQuietZone = function (row, startPattern) {\n        var quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone\n        // if there are not so many pixel at all let's try as many as possible\n        quietCount = quietCount < startPattern ? quietCount : startPattern;\n        for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {\n            if (row.get(i)) {\n                break;\n            }\n            quietCount--;\n        }\n        if (quietCount !== 0) {\n            // Unable to find the necessary number of quiet zone pixels.\n            throw new NotFoundException_1.default();\n        }\n    };\n    /*\n    /!**\n     * Skip all whitespace until we get to the first black line.\n     *\n     * @param row row of black/white values to search\n     * @return index of the first black line.\n     * @throws NotFoundException Throws exception if no black lines are found in the row\n     *!/*/\n    ITFReader.skipWhiteSpace = function (row) {\n        var width = row.getSize();\n        var endStart = row.getNextSet(0);\n        if (endStart === width) {\n            throw new NotFoundException_1.default();\n        }\n        return endStart;\n    };\n    /*/!**\n     * Identify where the end of the middle / payload section ends.\n     *\n     * @param row row of black/white values to search\n     * @return Array, containing index of start of 'end block' and end of 'end\n     *         block'\n     *!/*/\n    ITFReader.prototype.decodeEnd = function (row) {\n        // For convenience, reverse the row and then\n        // search from 'the start' for the end block\n        row.reverse();\n        try {\n            var endStart = ITFReader.skipWhiteSpace(row);\n            var endPattern = void 0;\n            try {\n                endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);\n            }\n            catch (error) {\n                if (error instanceof NotFoundException_1.default) {\n                    endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);\n                }\n            }\n            // The start & end patterns must be pre/post fixed by a quiet zone. This\n            // zone must be at least 10 times the width of a narrow line.\n            // ref: http://www.barcode-1.net/i25code.html\n            this.validateQuietZone(row, endPattern[0]);\n            // Now recalculate the indices of where the 'endblock' starts & stops to\n            // accommodate\n            // the reversed nature of the search\n            var temp = endPattern[0];\n            endPattern[0] = row.getSize() - endPattern[1];\n            endPattern[1] = row.getSize() - temp;\n            return endPattern;\n        }\n        finally {\n            // Put the row back the right way.\n            row.reverse();\n        }\n    };\n    /*\n    /!**\n     * @param row       row of black/white values to search\n     * @param rowOffset position to start search\n     * @param pattern   pattern of counts of number of black and white pixels that are\n     *                  being searched for as a pattern\n     * @return start/end horizontal offset of guard pattern, as an array of two\n     *         ints\n     * @throws NotFoundException if pattern is not found\n     *!/*/\n    ITFReader.findGuardPattern = function (row, rowOffset, pattern) {\n        var patternLength = pattern.length;\n        var counters = new Int32Array(patternLength);\n        var width = row.getSize();\n        var isWhite = false;\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        counters.fill(0);\n        for (var x = rowOffset; x < width; x++) {\n            if (row.get(x) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    if (OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {\n                        return [patternStart, x];\n                    }\n                    patternStart += counters[0] + counters[1];\n                    System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /*/!**\n     * Attempts to decode a sequence of ITF black/white lines into single\n     * digit.\n     *\n     * @param counters the counts of runs of observed black/white/black/... values\n     * @return The decoded digit\n     * @throws NotFoundException if digit cannot be decoded\n     *!/*/\n    ITFReader.decodeDigit = function (counters) {\n        var bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept\n        var bestMatch = -1;\n        var max = ITFReader.PATTERNS.length;\n        for (var i = 0; i < max; i++) {\n            var pattern = ITFReader.PATTERNS[i];\n            var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);\n            if (variance < bestVariance) {\n                bestVariance = variance;\n                bestMatch = i;\n            }\n            else if (variance === bestVariance) {\n                // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match\n                bestMatch = -1;\n            }\n        }\n        if (bestMatch >= 0) {\n            return bestMatch % 10;\n        }\n        else {\n            throw new NotFoundException_1.default();\n        }\n    };\n    ITFReader.PATTERNS = [\n        Int32Array.from([1, 1, 2, 2, 1]),\n        Int32Array.from([2, 1, 1, 1, 2]),\n        Int32Array.from([1, 2, 1, 1, 2]),\n        Int32Array.from([2, 2, 1, 1, 1]),\n        Int32Array.from([1, 1, 2, 1, 2]),\n        Int32Array.from([2, 1, 2, 1, 1]),\n        Int32Array.from([1, 2, 2, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 2]),\n        Int32Array.from([2, 1, 1, 2, 1]),\n        Int32Array.from([1, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 3, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 3]),\n        Int32Array.from([1, 3, 1, 1, 3]),\n        Int32Array.from([3, 3, 1, 1, 1]),\n        Int32Array.from([1, 1, 3, 1, 3]),\n        Int32Array.from([3, 1, 3, 1, 1]),\n        Int32Array.from([1, 3, 3, 1, 1]),\n        Int32Array.from([1, 1, 1, 3, 3]),\n        Int32Array.from([3, 1, 1, 3, 1]),\n        Int32Array.from([1, 3, 1, 3, 1]) // 9\n    ];\n    ITFReader.MAX_AVG_VARIANCE = 0.38;\n    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;\n    /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/\n    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];\n    /*/!**\n     * Start/end guard pattern.\n     *\n     * Note: The end pattern is reversed because the row is reversed before\n     * searching for the END_PATTERN\n     *!/*/\n    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);\n    ITFReader.END_PATTERN_REVERSED = [\n        Int32Array.from([1, 1, 2]),\n        Int32Array.from([1, 1, 3]) // 3x\n    ];\n    return ITFReader;\n}(OneDReader_1.default));\nexports.default = ITFReader;\n//# sourceMappingURL=ITFReader.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","defineProperty","BarcodeFormat_1","DecodeHintType_1","FormatException_1","NotFoundException_1","Result_1","ResultPoint_1","StringBuilder_1","System_1","OneDReader_1","ITFReader","_super","_this","apply","arguments","narrowLineWidth","decodeRow","ITFReader.prototype.decodeRow","rowNumber","row","hints","_a","startRange","decodeStart","endRange","decodeEnd","result","default","decodeMiddle","resultString","toString","allowedLengths","get","ALLOWED_LENGTHS","DEFAULT_ALLOWED_LENGTHS","lengthOK","maxAllowedLength","allowedLengths_1","allowedLengths_1_1","e_1_1","e_1","error","return","points","resultReturn","ITF","getTime","Date","ITFReader.decodeMiddle","payloadStart","payloadEnd","counterDigitPair","Int32Array","counterBlack","counterWhite","fill","recordPattern","k","twoK","bestMatch","decodeDigit","append","forEach","counterDigit","ITFReader.prototype.decodeStart","endStart","skipWhiteSpace","startPattern","findGuardPattern","START_PATTERN","validateQuietZone","ITFReader.prototype.validateQuietZone","quietCount","ITFReader.skipWhiteSpace","width","getSize","getNextSet","ITFReader.prototype.decodeEnd","reverse","endPattern","END_PATTERN_REVERSED","temp","ITFReader.findGuardPattern","rowOffset","pattern","patternLength","counters","isWhite","counterPosition","patternStart","x","patternMatchVariance","MAX_INDIVIDUAL_VARIANCE","MAX_AVG_VARIANCE","arraycopy","ITFReader.decodeDigit","bestVariance","max","PATTERNS","variance","from"]
}
