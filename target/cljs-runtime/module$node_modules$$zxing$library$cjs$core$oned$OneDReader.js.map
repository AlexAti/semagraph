{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$oned$OneDReader.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/oned/OneDReader.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$oned$OneDReader\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BitArray_1 = require(\"../common/BitArray\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * Encapsulates functionality and implementation that is common to all families\n * of one-dimensional barcodes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar OneDReader = /** @class */ (function () {\n    function OneDReader() {\n    }\n    /*\n    @Override\n    public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n      return decode(image, null);\n    }\n    */\n    // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n    // @Override\n    OneDReader.prototype.decode = function (image, hints) {\n        try {\n            return this.doDecode(image, hints);\n        }\n        catch (nfe) {\n            var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);\n            if (tryHarder && image.isRotateSupported()) {\n                var rotatedImage = image.rotateCounterClockwise();\n                var result = this.doDecode(rotatedImage, hints);\n                // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n                var metadata = result.getResultMetadata();\n                var orientation_1 = 270;\n                if (metadata !== null && (metadata.get(ResultMetadataType_1.default.ORIENTATION) === true)) {\n                    // But if we found it reversed in doDecode(), add in that result here:\n                    orientation_1 = (orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360);\n                }\n                result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1);\n                // Update result points\n                var points = result.getResultPoints();\n                if (points !== null) {\n                    var height = rotatedImage.getHeight();\n                    for (var i = 0; i < points.length; i++) {\n                        points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());\n                    }\n                }\n                return result;\n            }\n            else {\n                throw new NotFoundException_1.default();\n            }\n        }\n    };\n    // @Override\n    OneDReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * We're going to examine rows from the middle outward, searching alternately above and below the\n     * middle, and farther out each time. rowStep is the number of rows between each successive\n     * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n     * middle + rowStep, then middle - (2 * rowStep), etc.\n     * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n     * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n     * image if \"trying harder\".\n     *\n     * @param image The image to decode\n     * @param hints Any hints that were requested\n     * @return The contents of the decoded barcode\n     * @throws NotFoundException Any spontaneous errors which occur\n     */\n    OneDReader.prototype.doDecode = function (image, hints) {\n        var width = image.getWidth();\n        var height = image.getHeight();\n        var row = new BitArray_1.default(width);\n        var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);\n        var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n        var maxLines;\n        if (tryHarder) {\n            maxLines = height; // Look at the whole image, not just the center\n        }\n        else {\n            maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n        }\n        var middle = Math.trunc(height / 2);\n        for (var x = 0; x < maxLines; x++) {\n            // Scanning from the middle out. Determine which row we're looking at next:\n            var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n            var isAbove = (x & 0x01) === 0; // i.e. is x even?\n            var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n            if (rowNumber < 0 || rowNumber >= height) {\n                // Oops, if we run off the top or bottom, stop\n                break;\n            }\n            // Estimate black point for this row and load it:\n            try {\n                row = image.getBlackRow(rowNumber, row);\n            }\n            catch (ignored) {\n                continue;\n            }\n            var _loop_1 = function (attempt) {\n                if (attempt === 1) { // trying again?\n                    row.reverse(); // reverse the row and continue\n                    // This means we will only ever draw result points *once* in the life of this method\n                    // since we want to avoid drawing the wrong points after flipping the row, and,\n                    // don't want to clutter with noise from every single row scan -- just the scans\n                    // that start on the center line.\n                    if (hints && (hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true)) {\n                        var newHints_1 = new Map();\n                        hints.forEach(function (hint, key) { return newHints_1.set(key, hint); });\n                        newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n                        hints = newHints_1;\n                    }\n                }\n                try {\n                    // Look for a barcode\n                    var result = this_1.decodeRow(rowNumber, row, hints);\n                    // We found our barcode\n                    if (attempt === 1) {\n                        // But it was upside down, so note that\n                        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180);\n                        // And remember to flip the result points horizontally.\n                        var points = result.getResultPoints();\n                        if (points !== null) {\n                            points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());\n                            points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());\n                        }\n                    }\n                    return { value: result };\n                }\n                catch (re) {\n                    // continue -- just couldn't decode this row\n                }\n            };\n            var this_1 = this;\n            // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n            // handle decoding upside down barcodes.\n            for (var attempt = 0; attempt < 2; attempt++) {\n                var state_1 = _loop_1(attempt);\n                if (typeof state_1 === \"object\")\n                    return state_1.value;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /**\n     * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n     * The values are recorded in the given array, and the number of runs recorded is equal to the size\n     * of the array. If the row starts on a white pixel at the given start point, then the first count\n     * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n     * of black pixels if the row begin on a black pixels at that point.\n     *\n     * @param row row to count from\n     * @param start offset into row to start at\n     * @param counters array into which to record counts\n     * @throws NotFoundException if counters cannot be filled entirely from row before running out\n     *  of pixels\n     */\n    OneDReader.recordPattern = function (row, start, counters) {\n        var numCounters = counters.length;\n        for (var index = 0; index < numCounters; index++)\n            counters[index] = 0;\n        var end = row.getSize();\n        if (start >= end) {\n            throw new NotFoundException_1.default();\n        }\n        var isWhite = !row.get(start);\n        var counterPosition = 0;\n        var i = start;\n        while (i < end) {\n            if (row.get(i) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (++counterPosition === numCounters) {\n                    break;\n                }\n                else {\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            i++;\n        }\n        // If we read fully the last section of pixels and filled up our counters -- or filled\n        // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n        if (!(counterPosition === numCounters || (counterPosition === numCounters - 1 && i === end))) {\n            throw new NotFoundException_1.default();\n        }\n    };\n    OneDReader.recordPatternInReverse = function (row, start, counters) {\n        // This could be more efficient I guess\n        var numTransitionsLeft = counters.length;\n        var last = row.get(start);\n        while (start > 0 && numTransitionsLeft >= 0) {\n            if (row.get(--start) !== last) {\n                numTransitionsLeft--;\n                last = !last;\n            }\n        }\n        if (numTransitionsLeft >= 0) {\n            throw new NotFoundException_1.default();\n        }\n        OneDReader.recordPattern(row, start + 1, counters);\n    };\n    /**\n     * Determines how closely a set of observed counts of runs of black/white values matches a given\n     * target pattern. This is reported as the ratio of the total variance from the expected pattern\n     * proportions across all pattern elements, to the length of the pattern.\n     *\n     * @param counters observed counters\n     * @param pattern expected pattern\n     * @param maxIndividualVariance The most any counter can differ before we give up\n     * @return ratio of total variance between counters and pattern compared to total pattern size\n     */\n    OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n        var numCounters = counters.length;\n        var total = 0;\n        var patternLength = 0;\n        for (var i = 0; i < numCounters; i++) {\n            total += counters[i];\n            patternLength += pattern[i];\n        }\n        if (total < patternLength) {\n            // If we don't even have one pixel per unit of bar width, assume this is too small\n            // to reliably match, so fail:\n            return Number.POSITIVE_INFINITY;\n        }\n        var unitBarWidth = total / patternLength;\n        maxIndividualVariance *= unitBarWidth;\n        var totalVariance = 0.0;\n        for (var x = 0; x < numCounters; x++) {\n            var counter = counters[x];\n            var scaledPattern = pattern[x] * unitBarWidth;\n            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n            if (variance > maxIndividualVariance) {\n                return Number.POSITIVE_INFINITY;\n            }\n            totalVariance += variance;\n        }\n        return totalVariance / total;\n    };\n    return OneDReader;\n}());\nexports.default = OneDReader;\n//# sourceMappingURL=OneDReader.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","BitArray_1","DecodeHintType_1","ResultMetadataType_1","ResultPoint_1","NotFoundException_1","OneDReader","prototype","decode","OneDReader.prototype.decode","image","hints","doDecode","nfe","get","default","TRY_HARDER","isRotateSupported","rotatedImage","rotateCounterClockwise","result","metadata","getResultMetadata","orientation_1","ORIENTATION","putMetadata","points","getResultPoints","height","i","getHeight","length","getY","getX","reset","OneDReader.prototype.reset","OneDReader.prototype.doDecode","width","getWidth","row","tryHarder","rowStep","Math","max","maxLines","middle","trunc","x","rowStepsAboveOrBelow","rowNumber","getBlackRow","ignored","_loop_1","attempt","reverse","NEED_RESULT_POINT_CALLBACK","newHints_1","Map","forEach","hint","key","set","delete","this_1","decodeRow","re","state_1","recordPattern","OneDReader.recordPattern","start","counters","numCounters","index","end","getSize","isWhite","counterPosition","recordPatternInReverse","OneDReader.recordPatternInReverse","numTransitionsLeft","last","patternMatchVariance","OneDReader.patternMatchVariance","pattern","maxIndividualVariance","total","patternLength","Number","POSITIVE_INFINITY","unitBarWidth","totalVariance","counter","scaledPattern","variance"]
}
