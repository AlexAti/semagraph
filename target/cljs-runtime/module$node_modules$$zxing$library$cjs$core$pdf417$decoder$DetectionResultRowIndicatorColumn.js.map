{
"version":3,
"file":"module$node_modules$$zxing$library$cjs$core$pdf417$decoder$DetectionResultRowIndicatorColumn.js",
"lineCount":16,
"mappings":"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",
"sources":["node_modules/@zxing/library/cjs/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$zxing$library$cjs$core$pdf417$decoder$DetectionResultRowIndicatorColumn\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// import com.google.zxing.pdf417.PDF417Common;\nvar PDF417Common_1 = require(\"../PDF417Common\");\nvar BarcodeMetadata_1 = require(\"./BarcodeMetadata\");\nvar DetectionResultColumn_1 = require(\"./DetectionResultColumn\");\nvar BarcodeValue_1 = require(\"./BarcodeValue\");\n/**\n * @author Guenther Grau\n */\nvar DetectionResultRowIndicatorColumn = /** @class */ (function (_super) {\n    __extends(DetectionResultRowIndicatorColumn, _super);\n    function DetectionResultRowIndicatorColumn(boundingBox, isLeft) {\n        var _this = _super.call(this, boundingBox) || this;\n        _this._isLeft = isLeft;\n        return _this;\n    }\n    DetectionResultRowIndicatorColumn.prototype.setRowNumbers = function () {\n        var e_1, _a;\n        try {\n            for (var _b = __values(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var codeword = _c.value /*Codeword*/;\n                if (codeword != null) {\n                    codeword.setRowNumberAsRowIndicatorColumn();\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    // TODO implement properly\n    // TODO maybe we should add missing codewords to store the correct row number to make\n    // finding row numbers for other columns easier\n    // use row height count to make detection of invalid row numbers more reliable\n    DetectionResultRowIndicatorColumn.prototype.adjustCompleteIndicatorColumnRowNumbers = function (barcodeMetadata) {\n        var codewords = this.getCodewords();\n        this.setRowNumbers();\n        this.removeIncorrectCodewords(codewords, barcodeMetadata);\n        var boundingBox = this.getBoundingBox();\n        var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n        var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n        // We need to be careful using the average row height. Barcode could be skewed so that we have smaller and\n        // taller rows\n        // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n        var barcodeRow = -1;\n        var maxRowHeight = 1;\n        var currentRowHeight = 0;\n        for (var codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {\n            if (codewords[codewordsRow] == null) {\n                continue;\n            }\n            var codeword = codewords[codewordsRow];\n            //      float expectedRowNumber = (codewordsRow - firstRow) / averageRowHeight;\n            //      if (Math.abs(codeword.getRowNumber() - expectedRowNumber) > 2) {\n            //        SimpleLog.log(LEVEL.WARNING,\n            //            \"Removing codeword, rowNumberSkew too high, codeword[\" + codewordsRow + \"]: Expected Row: \" +\n            //                expectedRowNumber + \", RealRow: \" + codeword.getRowNumber() + \", value: \" + codeword.getValue());\n            //        codewords[codewordsRow] = null;\n            //      }\n            var rowDifference = codeword.getRowNumber() - barcodeRow;\n            // TODO improve handling with case where first row indicator doesn't start with 0\n            if (rowDifference === 0) {\n                currentRowHeight++;\n            }\n            else if (rowDifference === 1) {\n                maxRowHeight = Math.max(maxRowHeight, currentRowHeight);\n                currentRowHeight = 1;\n                barcodeRow = codeword.getRowNumber();\n            }\n            else if (rowDifference < 0 ||\n                codeword.getRowNumber() >= barcodeMetadata.getRowCount() ||\n                rowDifference > codewordsRow) {\n                codewords[codewordsRow] = null;\n            }\n            else {\n                var checkedRows = void 0;\n                if (maxRowHeight > 2) {\n                    checkedRows = (maxRowHeight - 2) * rowDifference;\n                }\n                else {\n                    checkedRows = rowDifference;\n                }\n                var closePreviousCodewordFound = checkedRows >= codewordsRow;\n                for (var i /*int*/ = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {\n                    // there must be (height * rowDifference) number of codewords missing. For now we assume height = 1.\n                    // This should hopefully get rid of most problems already.\n                    closePreviousCodewordFound = codewords[codewordsRow - i] != null;\n                }\n                if (closePreviousCodewordFound) {\n                    codewords[codewordsRow] = null;\n                }\n                else {\n                    barcodeRow = codeword.getRowNumber();\n                    currentRowHeight = 1;\n                }\n            }\n        }\n        // return (int) (averageRowHeight + 0.5);\n    };\n    DetectionResultRowIndicatorColumn.prototype.getRowHeights = function () {\n        var e_2, _a;\n        var barcodeMetadata = this.getBarcodeMetadata();\n        if (barcodeMetadata == null) {\n            return null;\n        }\n        this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);\n        var result = new Int32Array(barcodeMetadata.getRowCount());\n        try {\n            for (var _b = __values(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var codeword = _c.value /*Codeword*/;\n                if (codeword != null) {\n                    var rowNumber = codeword.getRowNumber();\n                    if (rowNumber >= result.length) {\n                        // We have more rows than the barcode metadata allows for, ignore them.\n                        continue;\n                    }\n                    result[rowNumber]++;\n                } // else throw exception?\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return result;\n    };\n    // TODO maybe we should add missing codewords to store the correct row number to make\n    // finding row numbers for other columns easier\n    // use row height count to make detection of invalid row numbers more reliable\n    DetectionResultRowIndicatorColumn.prototype.adjustIncompleteIndicatorColumnRowNumbers = function (barcodeMetadata) {\n        var boundingBox = this.getBoundingBox();\n        var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n        var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n        // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n        var codewords = this.getCodewords();\n        var barcodeRow = -1;\n        var maxRowHeight = 1;\n        var currentRowHeight = 0;\n        for (var codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {\n            if (codewords[codewordsRow] == null) {\n                continue;\n            }\n            var codeword = codewords[codewordsRow];\n            codeword.setRowNumberAsRowIndicatorColumn();\n            var rowDifference = codeword.getRowNumber() - barcodeRow;\n            // TODO improve handling with case where first row indicator doesn't start with 0\n            if (rowDifference === 0) {\n                currentRowHeight++;\n            }\n            else if (rowDifference === 1) {\n                maxRowHeight = Math.max(maxRowHeight, currentRowHeight);\n                currentRowHeight = 1;\n                barcodeRow = codeword.getRowNumber();\n            }\n            else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {\n                codewords[codewordsRow] = null;\n            }\n            else {\n                barcodeRow = codeword.getRowNumber();\n                currentRowHeight = 1;\n            }\n        }\n        // return (int) (averageRowHeight + 0.5);\n    };\n    DetectionResultRowIndicatorColumn.prototype.getBarcodeMetadata = function () {\n        var e_3, _a;\n        var codewords = this.getCodewords();\n        var barcodeColumnCount = new BarcodeValue_1.default();\n        var barcodeRowCountUpperPart = new BarcodeValue_1.default();\n        var barcodeRowCountLowerPart = new BarcodeValue_1.default();\n        var barcodeECLevel = new BarcodeValue_1.default();\n        try {\n            for (var codewords_1 = __values(codewords), codewords_1_1 = codewords_1.next(); !codewords_1_1.done; codewords_1_1 = codewords_1.next()) {\n                var codeword = codewords_1_1.value /*Codeword*/;\n                if (codeword == null) {\n                    continue;\n                }\n                codeword.setRowNumberAsRowIndicatorColumn();\n                var rowIndicatorValue = codeword.getValue() % 30;\n                var codewordRowNumber = codeword.getRowNumber();\n                if (!this._isLeft) {\n                    codewordRowNumber += 2;\n                }\n                switch (codewordRowNumber % 3) {\n                    case 0:\n                        barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);\n                        break;\n                    case 1:\n                        barcodeECLevel.setValue(rowIndicatorValue / 3);\n                        barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);\n                        break;\n                    case 2:\n                        barcodeColumnCount.setValue(rowIndicatorValue + 1);\n                        break;\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (codewords_1_1 && !codewords_1_1.done && (_a = codewords_1.return)) _a.call(codewords_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        // Maybe we should check if we have ambiguous values?\n        if ((barcodeColumnCount.getValue().length === 0) ||\n            (barcodeRowCountUpperPart.getValue().length === 0) ||\n            (barcodeRowCountLowerPart.getValue().length === 0) ||\n            (barcodeECLevel.getValue().length === 0) ||\n            barcodeColumnCount.getValue()[0] < 1 ||\n            barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common_1.default.MIN_ROWS_IN_BARCODE ||\n            barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common_1.default.MAX_ROWS_IN_BARCODE) {\n            return null;\n        }\n        var barcodeMetadata = new BarcodeMetadata_1.default(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);\n        this.removeIncorrectCodewords(codewords, barcodeMetadata);\n        return barcodeMetadata;\n    };\n    DetectionResultRowIndicatorColumn.prototype.removeIncorrectCodewords = function (codewords, barcodeMetadata) {\n        // Remove codewords which do not match the metadata\n        // TODO Maybe we should keep the incorrect codewords for the start and end positions?\n        for (var codewordRow /*int*/ = 0; codewordRow < codewords.length; codewordRow++) {\n            var codeword = codewords[codewordRow];\n            if (codewords[codewordRow] == null) {\n                continue;\n            }\n            var rowIndicatorValue = codeword.getValue() % 30;\n            var codewordRowNumber = codeword.getRowNumber();\n            if (codewordRowNumber > barcodeMetadata.getRowCount()) {\n                codewords[codewordRow] = null;\n                continue;\n            }\n            if (!this._isLeft) {\n                codewordRowNumber += 2;\n            }\n            switch (codewordRowNumber % 3) {\n                case 0:\n                    if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {\n                        codewords[codewordRow] = null;\n                    }\n                    break;\n                case 1:\n                    if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() ||\n                        rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {\n                        codewords[codewordRow] = null;\n                    }\n                    break;\n                case 2:\n                    if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {\n                        codewords[codewordRow] = null;\n                    }\n                    break;\n            }\n        }\n    };\n    DetectionResultRowIndicatorColumn.prototype.isLeft = function () {\n        return this._isLeft;\n    };\n    // @Override\n    DetectionResultRowIndicatorColumn.prototype.toString = function () {\n        return 'IsLeft: ' + this._isLeft + '\\n' + _super.prototype.toString.call(this);\n    };\n    return DetectionResultRowIndicatorColumn;\n}(DetectionResultColumn_1.default));\nexports.default = DetectionResultRowIndicatorColumn;\n//# sourceMappingURL=DetectionResultRowIndicatorColumn.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","defineProperty","PDF417Common_1","BarcodeMetadata_1","DetectionResultColumn_1","BarcodeValue_1","DetectionResultRowIndicatorColumn","_super","boundingBox","isLeft","_this","_isLeft","setRowNumbers","DetectionResultRowIndicatorColumn.prototype.setRowNumbers","_a","_b","getCodewords","_c","codeword","setRowNumberAsRowIndicatorColumn","e_1_1","e_1","error","return","adjustCompleteIndicatorColumnRowNumbers","DetectionResultRowIndicatorColumn.prototype.adjustCompleteIndicatorColumnRowNumbers","barcodeMetadata","codewords","removeIncorrectCodewords","getBoundingBox","top","getTopLeft","getTopRight","bottom","getBottomLeft","getBottomRight","firstRow","imageRowToCodewordIndex","Math","trunc","getY","lastRow","barcodeRow","maxRowHeight","currentRowHeight","codewordsRow","rowDifference","getRowNumber","max","getRowCount","checkedRows","closePreviousCodewordFound","getRowHeights","DetectionResultRowIndicatorColumn.prototype.getRowHeights","getBarcodeMetadata","adjustIncompleteIndicatorColumnRowNumbers","result","Int32Array","rowNumber","e_2_1","e_2","DetectionResultRowIndicatorColumn.prototype.adjustIncompleteIndicatorColumnRowNumbers","DetectionResultRowIndicatorColumn.prototype.getBarcodeMetadata","barcodeColumnCount","default","barcodeRowCountUpperPart","barcodeRowCountLowerPart","barcodeECLevel","codewords_1","codewords_1_1","rowIndicatorValue","getValue","codewordRowNumber","setValue","e_3_1","e_3","MIN_ROWS_IN_BARCODE","MAX_ROWS_IN_BARCODE","DetectionResultRowIndicatorColumn.prototype.removeIncorrectCodewords","codewordRow","getRowCountUpperPart","getErrorCorrectionLevel","getRowCountLowerPart","getColumnCount","DetectionResultRowIndicatorColumn.prototype.isLeft","toString","DetectionResultRowIndicatorColumn.prototype.toString"]
}
