{
"version":3,
"file":"module$node_modules$qrcode$lib$core$mask_pattern.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/qrcode/lib/core/mask-pattern.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$qrcode$lib$core$mask_pattern\"] = function(global,require,module,exports) {\n/**\n * Data mask pattern reference\n * @type {Object}\n */\nexports.Patterns = {\n  PATTERN000: 0,\n  PATTERN001: 1,\n  PATTERN010: 2,\n  PATTERN011: 3,\n  PATTERN100: 4,\n  PATTERN101: 5,\n  PATTERN110: 6,\n  PATTERN111: 7\n}\n\n/**\n * Weighted penalty scores for the undesirable features\n * @type {Object}\n */\nconst PenaltyScores = {\n  N1: 3,\n  N2: 3,\n  N3: 40,\n  N4: 10\n}\n\n/**\n * Check if mask pattern value is valid\n *\n * @param  {Number}  mask    Mask pattern\n * @return {Boolean}         true if valid, false otherwise\n */\nexports.isValid = function isValid (mask) {\n  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7\n}\n\n/**\n * Returns mask pattern from a value.\n * If value is not valid, returns undefined\n *\n * @param  {Number|String} value        Mask pattern value\n * @return {Number}                     Valid mask pattern or undefined\n */\nexports.from = function from (value) {\n  return exports.isValid(value) ? parseInt(value, 10) : undefined\n}\n\n/**\n* Find adjacent modules in row/column with the same color\n* and assign a penalty value.\n*\n* Points: N1 + i\n* i is the amount by which the number of adjacent modules of the same color exceeds 5\n*/\nexports.getPenaltyN1 = function getPenaltyN1 (data) {\n  const size = data.size\n  let points = 0\n  let sameCountCol = 0\n  let sameCountRow = 0\n  let lastCol = null\n  let lastRow = null\n\n  for (let row = 0; row < size; row++) {\n    sameCountCol = sameCountRow = 0\n    lastCol = lastRow = null\n\n    for (let col = 0; col < size; col++) {\n      let module = data.get(row, col)\n      if (module === lastCol) {\n        sameCountCol++\n      } else {\n        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n        lastCol = module\n        sameCountCol = 1\n      }\n\n      module = data.get(col, row)\n      if (module === lastRow) {\n        sameCountRow++\n      } else {\n        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n        lastRow = module\n        sameCountRow = 1\n      }\n    }\n\n    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n  }\n\n  return points\n}\n\n/**\n * Find 2x2 blocks with the same color and assign a penalty value\n *\n * Points: N2 * (m - 1) * (n - 1)\n */\nexports.getPenaltyN2 = function getPenaltyN2 (data) {\n  const size = data.size\n  let points = 0\n\n  for (let row = 0; row < size - 1; row++) {\n    for (let col = 0; col < size - 1; col++) {\n      const last = data.get(row, col) +\n        data.get(row, col + 1) +\n        data.get(row + 1, col) +\n        data.get(row + 1, col + 1)\n\n      if (last === 4 || last === 0) points++\n    }\n  }\n\n  return points * PenaltyScores.N2\n}\n\n/**\n * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n * preceded or followed by light area 4 modules wide\n *\n * Points: N3 * number of pattern found\n */\nexports.getPenaltyN3 = function getPenaltyN3 (data) {\n  const size = data.size\n  let points = 0\n  let bitsCol = 0\n  let bitsRow = 0\n\n  for (let row = 0; row < size; row++) {\n    bitsCol = bitsRow = 0\n    for (let col = 0; col < size; col++) {\n      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)\n      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++\n\n      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)\n      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++\n    }\n  }\n\n  return points * PenaltyScores.N3\n}\n\n/**\n * Calculate proportion of dark modules in entire symbol\n *\n * Points: N4 * k\n *\n * k is the rating of the deviation of the proportion of dark modules\n * in the symbol from 50% in steps of 5%\n */\nexports.getPenaltyN4 = function getPenaltyN4 (data) {\n  let darkCount = 0\n  const modulesCount = data.data.length\n\n  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]\n\n  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)\n\n  return k * PenaltyScores.N4\n}\n\n/**\n * Return mask value at given position\n *\n * @param  {Number} maskPattern Pattern reference value\n * @param  {Number} i           Row\n * @param  {Number} j           Column\n * @return {Boolean}            Mask value\n */\nfunction getMaskAt (maskPattern, i, j) {\n  switch (maskPattern) {\n    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0\n    case exports.Patterns.PATTERN001: return i % 2 === 0\n    case exports.Patterns.PATTERN010: return j % 3 === 0\n    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0\n    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0\n    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0\n    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0\n    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0\n\n    default: throw new Error('bad maskPattern:' + maskPattern)\n  }\n}\n\n/**\n * Apply a mask pattern to a BitMatrix\n *\n * @param  {Number}    pattern Pattern reference number\n * @param  {BitMatrix} data    BitMatrix data\n */\nexports.applyMask = function applyMask (pattern, data) {\n  const size = data.size\n\n  for (let col = 0; col < size; col++) {\n    for (let row = 0; row < size; row++) {\n      if (data.isReserved(row, col)) continue\n      data.xor(row, col, getMaskAt(pattern, row, col))\n    }\n  }\n}\n\n/**\n * Returns the best mask pattern for data\n *\n * @param  {BitMatrix} data\n * @return {Number} Mask pattern reference number\n */\nexports.getBestMask = function getBestMask (data, setupFormatFunc) {\n  const numPatterns = Object.keys(exports.Patterns).length\n  let bestPattern = 0\n  let lowerPenalty = Infinity\n\n  for (let p = 0; p < numPatterns; p++) {\n    setupFormatFunc(p)\n    exports.applyMask(p, data)\n\n    // Calculate penalty\n    const penalty =\n      exports.getPenaltyN1(data) +\n      exports.getPenaltyN2(data) +\n      exports.getPenaltyN3(data) +\n      exports.getPenaltyN4(data)\n\n    // Undo previously applied mask\n    exports.applyMask(p, data)\n\n    if (penalty < lowerPenalty) {\n      lowerPenalty = penalty\n      bestPattern = p\n    }\n  }\n\n  return bestPattern\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","getMaskAt","maskPattern","i","j","Patterns","PATTERN000","PATTERN001","PATTERN010","PATTERN011","PATTERN100","Math","floor","PATTERN101","PATTERN110","PATTERN111","Error","isValid","exports.isValid","mask","isNaN","from","exports.from","value","parseInt","undefined","getPenaltyN1","exports.getPenaltyN1","data","size","points","sameCountCol","sameCountRow","lastCol","lastRow","row","col","get","N1","getPenaltyN2","exports.getPenaltyN2","last","N2","getPenaltyN3","exports.getPenaltyN3","bitsCol","bitsRow","N3","getPenaltyN4","exports.getPenaltyN4","darkCount","modulesCount","length","N4","abs","k","ceil","applyMask","exports.applyMask","pattern","isReserved","xor","getBestMask","exports.getBestMask","setupFormatFunc","numPatterns","Object","keys","bestPattern","lowerPenalty","Infinity","p","penalty"]
}
